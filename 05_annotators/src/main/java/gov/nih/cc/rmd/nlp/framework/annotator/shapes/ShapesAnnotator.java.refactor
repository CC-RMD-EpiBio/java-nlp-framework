/*
 * Copyright 2018 Ciitizen Corp. - All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains the property of Ciitizen Corp.
 * The intellectual and technical concepts contained herein are proprietary to
 * Ciitizen Corp. and may be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.  Dissemination of this information
 * or reproduction of this material is strictly forbidden.
 */
/**
 * Shapes finds emails, urls, zip codes, ....
 *
 *
 * @author  Guy Divita 
 * @created Jun 22, 2011
 *
 * [Utah/Salt Lake City Preamble Here]
 */
// ================================================
package gov.nih.cc.rmd.nlp.framework.annotator.shapes;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;

import org.apache.uima.UimaContext;
import org.apache.uima.analysis_component.JCasAnnotator_ImplBase;
import org.apache.uima.analysis_engine.AnalysisEngineProcessException;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.tcas.Annotation;
import org.apache.uima.resource.ResourceInitializationException;

import com.ciitizen.framework.model.NumberRange;
import com.ciitizen.framework.model.Person;
import com.ciitizen.framework.model.Shape;

import gov.nih.cc.rmd.nlp.framework.utils.terminologies.TermLookupInterface;
import gov.nih.cc.rmd.nlp.framework.utils.terminologies.lookup.LRAGRRow;
import gov.nih.cc.rmd.nlp.framework.utils.terminologies.lookup.TermLookupLocalTermsImpl;
import gov.nih.cc.rmd.nlp.framework.utils.terminologies.lookup.TermLookupLookupCiitizenImpl;
import com.ciitizen.handlers.DataTypeMatcher.Match;
import com.ciitizen.handlers.impl.DefaultDataTypeMatcher;
import com.ciitizen.model.ValueUnits;

import gov.va.chir.model.Line;
import gov.nih.cc.rmd.nlp.framework.utils.GLog;
import gov.nih.cc.rmd.nlp.framework.utils.ProfilePerformanceMeter;
import gov.nih.cc.rmd.nlp.framework.utils.U;
import gov.nih.cc.rmd.nlp.framework.utils.term.TermLookupLocal;
import gov.nih.cc.rmd.nlp.framework.utils.uima.UIMAUtil;

/**
 * The Class ShapesAnnotator.
 */
public class ShapesAnnotator extends JCasAnnotator_ImplBase {



  // -----------------------------------------
  /**
   * process .
   *
   * @param pJCas the j cas
   * @throws AnalysisEngineProcessException the analysis engine process
   *           exception
   */
  // -----------------------------------------
  @Override
  public void process(JCas pJCas) throws AnalysisEngineProcessException {

    try {
      this.performanceMeter.startCounter();

      List<Annotation> lines = UIMAUtil.getAnnotations( pJCas, Line.typeIndexID); 
   
      if ( lines != null && !lines.isEmpty()) {
      
        UIMAUtil.uniqueAnnotations(lines);
         for ( Annotation line : lines ) {
           int offset = line.getBegin();
           // process by tabs 
           String lineBuff = line.getCoveredText();
           if ( lineBuff != null && lineBuff.trim().length() > 0 ) { 
             String tabbedColumns[] = U.split( lineBuff, "\t");
           
             if ( tabbedColumns != null && tabbedColumns.length > 0 ) 
               for ( int i = 0; i < tabbedColumns.length; i++ ) {
                 findShapesInColumn ( pJCas, tabbedColumns[i], offset, offset + tabbedColumns[i].length() ) ;
                 offset+= tabbedColumns[i].length() + 1; // +1 for each tab
               }
           } // if line isn't empty
         } // end loop thru line annotations 
      } // end if there are lines
       
  } catch (
    
      Exception e) {
        e.printStackTrace();
        String msg = "Issue with one of the shapes " + e.toString();
        GLog.println(GLog.ERROR_LEVEL, this.getClass(), "process", msg);
      }
        

     } // end Method process() ----------------

          
  // =================================================
  /**
   * findShapesInColumn
   * 
   * @param pJCas
   * @param pColumn
   * @param pBeginOffset
  */
  // =================================================
   private void findShapesInColumn(JCas pJCas, String pColumn, int pBeginOffset, int pEndOffset) {
   
     boolean foundNumber = false;
     findEmailShape(pJCas, pColumn, pBeginOffset );
     findURLShape(pJCas,  pColumn, pBeginOffset );
     findPhoneShape( pJCas, pColumn, pBeginOffset );
     findZipCodeShape( pJCas, pColumn, pBeginOffset );
     findPersonShape( pJCas, pColumn, pBeginOffset );
     foundNumber = findNumberShape( pJCas, pColumn, pBeginOffset );
     if ( foundNumber ) {
       findNumberRangeShape ( pJCas, pColumn, pBeginOffset, pEndOffset );
       findUnitsOfMeasureShape( pJCas, pColumn, pBeginOffset, pEndOffset);
     }
     
  } // end Method processShapesInColumn() -----------


  // =================================================
  /**
   * findEmailShape 
   * 
   * @param pJCas
   * @param pColumn
   * @param pBeginOffset
  */
  // =================================================
  private final void findEmailShape(JCas pJCas, String pColumn, int pBeginOffset ) {

    try {
    // emails 
    List<Match<String>> matches = this.dataMatcher.getEmails( pColumn);
    if (matches != null && !matches.isEmpty())
      for (Match<String> aMatch : matches)
        createAnnotation(pJCas, com.ciitizen.framework.model.Email.class, pBeginOffset + aMatch.getStartIndex() , pBeginOffset + aMatch.getEndIndex());
    } catch (Exception e) {
      e.printStackTrace();
      String msg = "Issue with email shape detection " + e.toString();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "process", msg);
    }
  } // end Method findEmailShape() -------------------


  // =================================================
  /**
   * findURLShape 
   * 
   * @param pJCas
   * @param pColumn
   * @param pBeginOffset
  */
  // =================================================
  private final void findURLShape(JCas pJCas, String pColumn, int pBeginOffset ) {
    try {
      // urls
        List<Match<String>>matches = this.dataMatcher.getUrls( pColumn);
      if (matches != null && !matches.isEmpty())
        for (Match<String> aMatch : matches)
          createAnnotation(pJCas, com.ciitizen.framework.model.URL.class,  pBeginOffset + aMatch.getStartIndex(),  pBeginOffset + aMatch.getEndIndex());
    } catch (Exception e) {
      e.printStackTrace();
      String msg = "Issue with url shape detection " + e.toString();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "process", msg);
    }
  } // end Method findURLShape() ---------------------


  // =================================================
  /**
   * findPhoneShape 
   * 
   * @param pJCas
   * @param pColumn
   * @param pBeginOffset
  */
  // =================================================
 private final void findPhoneShape(JCas pJCas, String pColumn, int pBeginOffset ) {
   try {
     // phone numbers
       List<Match<String>>matches = this.dataMatcher.getPhoneNumbers( pColumn);
     if (matches != null && !matches.isEmpty())
       for (Match<String> aMatch : matches)
         createAnnotation(pJCas, com.ciitizen.framework.model.PhoneNumber.class, pBeginOffset +  aMatch.getStartIndex(),  pBeginOffset + aMatch.getEndIndex());
     } catch (Exception e) {
       e.printStackTrace();
       String msg = "Issue with phone number shape detection " + e.toString();
       GLog.println(GLog.ERROR_LEVEL, this.getClass(), "process", msg);
     }
    
  } // end Method findPhoneShape() --------------------


  // =================================================
  /**
   * findUnitsOfMeasureShape 
   * 
   * @param pJCas
   * @param pColumn
   * @param pBeginOffset
  */
  // =================================================
  private final void findUnitsOfMeasureShape(JCas pJCas, String pColumn, int pBeginOffset, int pEndOffset) {
   
     // units of measure
    // This needs to be fed dealing with tabs
    
    // within this line, look for numbers, 
    // feed a number or range + a window of tokens to the right (to a tab, to the end of line , to the next number)
    // to look for units of measure
    
    // find a number, then look the number + the rest - the column has a number in it, 
    
    // just feed in the non number part of the line - to the left of the number or range
    
    List<Annotation> allThingsNumber = UIMAUtil.getAnnotationsBySpan(pJCas, com.ciitizen.framework.model.Number.typeIndexID, pBeginOffset, pEndOffset );
    if ( allThingsNumber != null && !allThingsNumber.isEmpty()) {
    UIMAUtil.sortByOffset(allThingsNumber);
    
    int peekHereBegin = 0;
    int peekHereEnd = 0;
    String docText = pJCas.getDocumentText();
    if ( allThingsNumber != null && !allThingsNumber.isEmpty() ) {
      for ( int i = 0; i < allThingsNumber.size() -1; i++ ) {
        peekHereBegin = allThingsNumber.get(i).getEnd() +1;
        peekHereEnd = allThingsNumber.get(i+1).getBegin() -1;
        if ( peekHereBegin < peekHereEnd ) {
          String potentialUnitOfMeasure = docText.substring(peekHereBegin, peekHereEnd);
          if ( potentialUnitOfMeasure.trim().length() > 0 && !U.isOnlyPunctuation(potentialUnitOfMeasure.trim()) && !potentialUnitOfMeasure.trim().equals("-")) {
            findUnitsOfMeasureShapeAux( pJCas, potentialUnitOfMeasure, peekHereBegin, peekHereEnd);
          }
        }
      }
      // pick up the last part after the last number
      peekHereBegin = allThingsNumber.get( allThingsNumber.size() -1).getEnd();
      peekHereEnd = pEndOffset;
      if ( peekHereBegin < peekHereEnd ) {
        String potentialUnitOfMeasure = docText.substring(peekHereBegin, peekHereEnd);
        if ( potentialUnitOfMeasure.trim().length() > 0 && !U.isOnlyPunctuation(potentialUnitOfMeasure.trim()) && !potentialUnitOfMeasure.trim().equals("-")) {
        
          findUnitsOfMeasureShapeAux( pJCas, potentialUnitOfMeasure, peekHereBegin, peekHereEnd);
        }
      }
    } 
    }
  } // end Method() findUnitsOfMeasureShape() ---------------------
    
  
    // =================================================
    /**
     * findUnitsOfMeasureShape 
     * 
     * @param pJCas
     * @param pColumn
     * @param pBeginOffset
    */
    // =================================================
    private final void findUnitsOfMeasureShapeAux(JCas pJCas, String pColumn, int pBeginOffset, int pEndOffset) {
    
    try {
      
        List<LRAGRRow> lragrRows = this.terminologyLookup.getUnitLookup("UCUM", pColumn);
      
        if ( lragrRows != null ) {
         
          for ( LRAGRRow lragrRow : lragrRows ) {
            createAnnotation(pJCas, com.ciitizen.framework.model.UnitOfMeasure.class, pBeginOffset + lragrRow.getBeginOffsetInQuery(),  pBeginOffset + lragrRow.getEndOffsetInQuery());
          }
          
        }
    } catch (Exception e) {
      e.printStackTrace();
      String msg = "Issue with units of measure shape detection " + e.toString();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "process", msg);
    }
          
       
    
  } // end Method findUnitsOfMeasureShape() ---------


  // =================================================
  /**
   * findZipCodeShape 
   * 
   * @param pJCas
   * @param pColumn
   * @param pBeginOffset
  */
  // =================================================
  private final void findZipCodeShape(JCas pJCas, String pColumn, int pBeginOffset ) {
   
    
    try {
      // Zip codes
      List<Match<String>> zipCodeMatches = this.moreShapesRegexes.getZipCodes( pColumn );
      if (zipCodeMatches != null && !zipCodeMatches.isEmpty())
        for (Match<String> aMatch : zipCodeMatches)
          createAnnotation(pJCas, com.ciitizen.framework.model.Zipcode.class,  pBeginOffset + aMatch.getStartIndex(),  pBeginOffset + aMatch.getEndIndex());
      } catch (Exception e) {
        e.printStackTrace();
        String msg = "Issue with zip code shape detection " + e.toString();
        GLog.println(GLog.ERROR_LEVEL, this.getClass(), "process", msg);
      }
      
  } // end findZipCodeShape() -----------------------

    
        
  // =================================================
  /**
   * findPersonShape 
   * 
   * @param pJCas
   * @param pColumn
   * @param pBeginOffset
  */
  // =================================================
   private final void findPersonShape(JCas pJCas, String pColumn, int pBeginOffset ) {
    try {
      // person name
        List<Match<String>>matches = this.dataMatcher.getPersonNames(pColumn);
      if (matches != null && !matches.isEmpty())
        for (Match<String> aMatch : matches)
          createAnnotation(pJCas, Person.class, pBeginOffset + aMatch.getStartIndex(), pBeginOffset + aMatch.getEndIndex());
      } catch (Exception e) {
        e.printStackTrace();
        String msg = "Issue with person shape detection " + e.toString();
        GLog.println(GLog.ERROR_LEVEL, this.getClass(), "process", msg);
      }
   } // end Method findPersonShape() ---------------
    
   
// =================================================
/**
* findNumberShape  finds integer and real numbers, percents, fractions 
* 
* @param pJCas
* @param pColumn
* @param pBeginOffset
 * @return boolean   true if a number has been found
*/
// =================================================
private final boolean findNumberShape( JCas pJCas, String pColumn, int pBeginOffset ) {

   
   // don't make a number if this overlaps with an absolute date - no, wait, dates have not yet been found
   // when making a date - remove numbers that overlap.
   boolean returnVal = false;
   
   try {
   List<Match<String>>matches = this.moreShapesRegexes.getNumbers(pColumn );
   if (matches != null && !matches.isEmpty())
     for (Match<String> aMatch : matches) {
       
       createAnnotation(pJCas, com.ciitizen.framework.model.Number.class, pBeginOffset + aMatch.getStartIndex(), pBeginOffset + aMatch.getEndIndex());
       returnVal = true;
     }
     } catch (Exception e) {
     e.printStackTrace();
     String msg = "Issue with person shape detection " + e.toString();
     GLog.println(GLog.ERROR_LEVEL, this.getClass(), "process", msg);
   }
 
   return returnVal;
} // end Method findNumberShape() -----------------
 
 

//=================================================
/**
* findNumberRangeShape  finds two numbers that either have a - or spaces (not a tab) in them
* 
* @param pJCas
* @param pColumn
* @param pBeginOffset
* @return boolean   true if a range was found
*/
//=================================================
private final boolean findNumberRangeShape(JCas pJCas, String pColumn, int pBeginOffset, int pEndOffset ) {

   boolean returnVal = false;
  List<Annotation> numbers = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas,  com.ciitizen.framework.model.Number.typeIndexID, pBeginOffset, pEndOffset );

  if ( numbers != null && numbers.size() > 1) {
    if ( numbers.size() == 2) {
      String docText = pJCas.getDocumentText();
      // look for a dash between these numbers
      UIMAUtil.sortByOffset(numbers);
      String stuffInbetween = docText.substring( numbers.get(0).getEnd(), numbers.get(1).getBegin() ); 
   
      if ( stuffInbetween.trim().equals("-") || (!stuffInbetween.contains("\t") && stuffInbetween.trim().length() == 0 )) {
        makeRange( pJCas, numbers.get(0), numbers.get(1));
        returnVal = true;
      }
      
    } else  {
      // ---- 
    }
  }
  return returnVal;
} // end Method findNumberRangeShape() -----------

   
  
  // =================================================
/**
 * makeRange 
 * 
 * @param pJCas
 * @param pNumber1
 * @param pNumber2
*/
// =================================================
  private NumberRange makeRange(JCas pJCas, Annotation pNumber1, Annotation pNumber2) {
 
    NumberRange statement = new NumberRange( pJCas );
    statement.setBegin(  pNumber1.getBegin());
    statement.setEnd(  pNumber2.getEnd() );
    statement.setId(   "ShapesAnnotator_Range_" + annotationCounter++);
    statement.addToIndexes();
    
    
  return statement;
  
}


  // -----------------------------------------
  /**
   * createAnnotation will create an annotation of the class pClassType.
   *
   * @param pJCas the j cas
   * @param pClassName the class name
   * @param pBeginOffset the begin offset
   * @param pEndOffset the end offset
   */
  // -----------------------------------------
  private void createAnnotation(JCas pJCas, Class<?> pClassName, int pBeginOffset, int pEndOffset) {

    try {
      Constructor<?> c = pClassName.getConstructor(new Class[] {
          JCas.class
      });
      Object statement = c.newInstance(pJCas);

      ((Shape) statement).setBegin(pBeginOffset);
      ((Shape) statement).setEnd(pEndOffset);
      ((Shape) statement).setId("ShapesAnnotator_" + annotationCounter++);

      ((Shape) statement).addToIndexes(pJCas);

    } catch (Exception e) {
      e.printStackTrace();
      GLog.println( GLog.ERROR_LEVEL, this.getClass(), "createAnnotation", "Something went wrong here " + e.toString());
    }

  } // end Method createAnnotation() ---

  // ----------------------------------
  /**
   * destroy.
   */
  // ----------------------------------
  @Override
  public void destroy() {
    this.performanceMeter.writeProfile(this.getClass().getSimpleName());
  }

  // ----------------------------------
  /**
   * initialize This is the standard uima way to pass parameters to an
   * annotator. It is cumbersome. It requires creating a config file with params
   * in it, making it difficult to dynamically pass in parameters.
   * 
   * This method merges the uima way and keeping the ability to dynamically pass
   * parameters into the class via - putting all parameters in a string array
   * called "args" with each row containing a --key=value format. This way,
   * arguments could be directly passed from command line, or read from a config
   * file, or dynamically added to that string passed in.
   * 
   * It is important to adhere to the posix style "--" prefix and include a
   * "=someValue" to fill in the value to the key.
   *
   * @param aContext the a context
   * @throws ResourceInitializationException the resource initialization
   *           exception
   */
  // ----------------------------------
  @Override
  public void initialize(UimaContext aContext) throws ResourceInitializationException {

    String[] args = null;
    try {
      args = (String[]) aContext.getConfigParameterValue("args");

      initialize(args);

    } catch (Exception e) {
      String msg = "Issue in initializing class " + this.getClass().getName() + " " + e.toString();
      GLog.println(GLog.ERROR_LEVEL, msg); // <------ use your own logging here
      throw new ResourceInitializationException();
    }

  } // end Method initialize() -------

  // ----------------------------------
  /**
   * initialize initializes the class. Parameters are passed in via a String
   * array with each row containing a --key=value format.
   * 
   * It is important to adhere to the posix style "--" prefix and include a
   * "=someValue" to fill in the value to the key.
   *
   * @param pArgs the args
   * @throws ResourceInitializationException the resource initialization
   *           exception
   */
  // ----------------------------------
  public void initialize(String[] pArgs) throws ResourceInitializationException {

    try {
      this.performanceMeter = new ProfilePerformanceMeter(pArgs, this.getClass().getSimpleName());

      this.dataMatcher = new DefaultDataTypeMatcher();

      this.moreShapesRegexes = new MoreDataTypeMatcher(pArgs);
      
     
      this.terminologyLookup = new  TermLookupLocalTermsImpl();
      this.terminologyLookup.init(pArgs, terminologyFiles);

    } catch (Exception e) {
      e.printStackTrace();
      String msg = "Issue initizlizng shapes " + e.toString();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "initialize", msg);
      throw new ResourceInitializationException();
    }
  } // end Method initialize() -------

  // ---------------------------------------
  // Global Variables
  /** The annotation counter. */
  // ---------------------------------------
  protected int annotationCounter = 0; // new Term Counter.

  /** The performance meter. */
  private ProfilePerformanceMeter performanceMeter = null;
  /** The data matcher. */
  private DefaultDataTypeMatcher dataMatcher;

  private TermLookupInterface  terminologyLookup = null;

  /** The more shapes regexes. */
  private MoreDataTypeMatcher moreShapesRegexes;
  

} // end Class LineAnnotator() ---------------
