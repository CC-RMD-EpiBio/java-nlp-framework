/*
 * Copyright 2018 Ciitizen Corp. - All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains the property of Ciitizen Corp.
 * The intellectual and technical concepts contained herein are proprietary to
 * Ciitizen Corp. and may be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.  Dissemination of this information
 * or reproduction of this material is strictly forbidden.
 */
/**
 * VitalsAnnotator decomposes the vitals section to its constituent parts
 *   test name 
 *   value
 *   eventDate (optional)
 *  
 *  This is the first of two annotators 
 *  The second annotator will lookup each test name
 *  to map to a loic code.  If the loinc code
 *  isn't found, that observation will be removed.
 *  
 *
 * @author  Guy Divita 
 * @created Aug 27, 2018
 *
 */
// ================================================
package gov.nih.cc.rmd.nlp.framework.annotator.vitals;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;

import org.apache.uima.UimaContext;
import org.apache.uima.analysis_component.JCasAnnotator_ImplBase;
import org.apache.uima.analysis_engine.AnalysisEngineProcessException;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.tcas.Annotation;
import org.apache.uima.resource.ResourceInitializationException;


import com.ciitizen.ClinicalStatusEvidence;
import com.ciitizen.framework.Observation;
import com.ciitizen.framework.ObservationEvidence;
import com.ciitizen.framework.ObservationsPanel;
import com.ciitizen.framework.SectionZone;
import com.ciitizen.framework.TestName;
import com.ciitizen.framework.TestValue;
import com.ciitizen.framework.VitalsObservation;
import com.ciitizen.framework.VitalsObservationsPanel;
import com.ciitizen.framework.model.Number;
import com.ciitizen.framework.model.UnitOfMeasure;

import gov.nih.cc.rmd.nlp.framework.utils.terminologies.TermLookupFactory;
import gov.nih.cc.rmd.nlp.framework.utils.terminologies.TermLookupInterface;
import gov.nih.cc.rmd.nlp.framework.utils.terminologies.lookup.LRAGRRow;
import gov.nih.cc.rmd.nlp.framework.utils.terminologies.utilities.LexRecord;
import gov.va.chir.model.LexicalElement;
import gov.va.chir.model.Line;
import gov.va.vinci.model.temporal.AbsoluteDate;
import gov.va.vinci.model.temporal.AbsoluteTime;
import gov.va.vinci.model.temporal.EventDate;
import gov.nih.cc.rmd.nlp.framework.utils.GLog;
import gov.nih.cc.rmd.nlp.framework.utils.ProfilePerformanceMeter;
import gov.nih.cc.rmd.nlp.framework.utils.U;
import gov.nih.cc.rmd.nlp.framework.utils.uima.UIMAUtil;

/**
 * Annotator for vitals.
 */
public class VitalsAnnotator extends JCasAnnotator_ImplBase {

 
  // -----------------------------------------
  /**
   * process retrieves lines of the document, labels those that are questions as
   * QuestionAndAnswer elements.
   * 
   * 
   */
  // -----------------------------------------
  @Override
  public void process(JCas pJCas) throws AnalysisEngineProcessException {

    try {

      this.performanceMeter.startCounter();
      
      //      String docName = VUIMAUtil.getDocumentId(pJCas);
    
      // retrieve section zones that are marked with resultSectionEvidence -
      // these can
      // be ccda Panel or Procedure zones

      List<Annotation> vitalsSectionSections = getVitalsSectionSections(pJCas);

      if (vitalsSectionSections != null && !vitalsSectionSections.isEmpty())
        for (Annotation section : vitalsSectionSections)
          processVitalsSection(pJCas, section);

      this.performanceMeter.stopCounter();
    } catch (Exception e) {
      e.printStackTrace();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "process",
          "Issue with " + this.getClass().getName() + " " + e.toString());
      // throw new AnalysisEngineProcessException();
    }
   
  } // end Method process() ----------------

  // =================================================
  /**
   * processVitalsSection breaks this section into observations
     * 
     * sets the section's event/statement date
     * 
     * @param pJCas
     * @param pSection
    */
    // =================================================
    private final void processVitalsSection(JCas pJCas, Annotation pSection) {
     
      // Find the statement/event date from the first lines
     
     
      String panelName = ((SectionZone)pSection).getSectionName();
    List<Annotation> lines = UIMAUtil.getAnnotationsBySpan(pJCas, Line.typeIndexID, pSection.getBegin(), pSection.getEnd());
      
    
      int dateLines = 0;
      if ( lines != null && !lines.isEmpty()) {
        lines = removeBlankLines( lines);
        List<Annotation> dates = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas, AbsoluteDate.typeIndexID, pSection.getBegin(), pSection.getEnd() ,false );
        if ( dates != null && !dates.isEmpty()) 
           dateLines = dates.size();
       
//        if ( lines.size() > 2 && lines.get(1).getCoveredText() != null && lines.get(1).getCoveredText().trim().equals("Body") ) 
//          processVitalsFormat3( pJCas, lines, panelName, pSection );
        
//        else //if ( lines.size() > 3 && dateLines > 2)
          processVitalsFormat2( pJCas, lines, panelName, pSection );

        // BAC: we shouldn't do this below, we're not trying to tune exactly to these
        // files, and especially where we don't know the column headers and OCR doesn't work
        // properly - we should just ignore these
//        else if ( lines.size() < 5)
//          processVitalsFormat1( pJCas, lines, panelName, pSection );
//       
//        else
//          processVitalsFormat2( pJCas, lines, panelName, pSection );
      
        
      }
      
    } // end Method processVitalsSection() ---------

  // =================================================
  /**
   * removeBlankLines
   * 
   * @param lines
   * @return
  */
  // =================================================
  private final List<Annotation> removeBlankLines(List<Annotation> lines) {
   
    List<Annotation> returnVal = new ArrayList<Annotation>();
    
    for ( int i = 0; i < lines.size(); i++ ) {
      String txt = lines.get(i).getCoveredText();
      if ( txt != null && txt.trim().length() != 0)
        returnVal.add(lines.get(i));
    }
    
    
    return returnVal;
  } // end Method removeBlankLines() -----------------

  // =================================================
  /**
   * processVitalsFormat1 this is the format where the vitals
   * names are on one line, and values are on the next line.
   * In coluumns.
   * 
   * @param pJCas
   * @param panelName 
   * @param lines 
   * @param pSection
  */
  // =================================================
  @SuppressWarnings("unused")
  private final void processVitalsFormat1(JCas pJCas, List<Annotation> pLines, String panelName, Annotation pSection) {

    // parse the second line 
    //    absorb Absolute Date
    //    absorb Absolute Time
    //    absorb Height - the next number and unit of measure
    //    absorb weight - the next number and unit of measure
    //    absorb bmi    - the next number and unit of measure
    //    absorb Pulse Rate
    //    absorb blood pressure 2 numbers and a unit of measure
    //    absorb Temperature  a number and unit of measure
    //    absorb respiratory rate number and unit of measure
    
    // iterate through the lines until you get to the line after
    // the header
  
    Annotation payloadLine = getHeaderAndPayloadLine(pJCas, pLines );
   
    if ( payloadLine == null ) return;
    
    int  lineEnd = payloadLine.getEnd();
    int  startPosition = payloadLine.getBegin();
    Annotation eventDate             = getEventDate(          pJCas,                             payloadLine);                        if ( eventDate != null )             startPosition = eventDate.getEnd() ;
    Annotation eventTime             = getEventTime(          pJCas,                             payloadLine);                        if ( eventTime != null )             startPosition = eventTime.getEnd() ;
    Annotation height                = getNumberAndUnit( pJCas, HEIGHT_LOINC_TEST_NAME,               startPosition, lineEnd, eventDate);  if ( height != null )                startPosition = height.getEnd() ;
    Annotation weight                = getNumberAndUnit( pJCas, WEIGHT_LOINC_TEST_NAME,               startPosition, lineEnd, eventDate);  if ( weight != null )                startPosition = weight.getEnd() ;
    Annotation bmi                   = getNumberAndUnit( pJCas, BMI_LOINC_TEST_NAME,                  startPosition, lineEnd, eventDate);  if ( bmi != null )                   startPosition = bmi.getEnd() + 2; // <---- see note below
    Annotation pulseRate             = getNumberAndUnit( pJCas, PULSE_RATE_LOINC_TEST_NAME,           startPosition, lineEnd, eventDate);  if ( pulseRate != null )             startPosition = pulseRate.getEnd() ;
   
    Annotation bloodPressureDistolic = getNumber(        pJCas, DIOSTOLIC_LOINC_TEST_NAME,            startPosition, lineEnd, eventDate);  if ( bloodPressureDistolic != null ) startPosition = bloodPressureDistolic.getEnd() ;
    Annotation bloodPressureSystolic = getNumber(        pJCas, SYSTOLIC_LOINC_TEST_NAME,             startPosition, lineEnd, eventDate);  if ( bloodPressureSystolic != null ) startPosition = bloodPressureSystolic.getEnd() ;
    Annotation bloodPressureUnit     = getUnitOfMeasure( pJCas,                                  startPosition, lineEnd );            if ( bloodPressureUnit != null )     startPosition = bloodPressureUnit.getEnd() ;
    Annotation bloodPressure         = createBloodPressureObserevation( pJCas, bloodPressureDistolic, bloodPressureSystolic, bloodPressureUnit, eventDate );
    
    Annotation temperature           = getNumberAndUnit( pJCas, TEMPERATURE_LOINC_TEST_NAME,          startPosition, lineEnd, eventDate);  if ( temperature != null )           startPosition = temperature.getEnd() ;
    Annotation respiratoryRate       = getNumberAndUnit( pJCas, RESPIRATORY_RATE_LOINC_TEST_NAME,     startPosition, lineEnd, eventDate);  if ( respiratoryRate != null )       startPosition = respiratoryRate.getEnd() ;
   
    
    // note:  the +2 is needed to move the parser beyond the ((2) part of the kg/meter(2) unit of measure - the unit of measure scanner 
    //        does not currently pick up the (2) part as currently configured, even if kg/meter(2) is a local synonym 
    
    List<Annotation> vitalsObservations = new ArrayList<Annotation>( 10 );
    if ( height != null )                vitalsObservations.add( height);
    if ( weight != null )                vitalsObservations.add( weight );
    if ( bmi != null )                   vitalsObservations.add( bmi);
    if ( pulseRate != null )             vitalsObservations.add( pulseRate);
    if ( bloodPressure != null )         vitalsObservations.add( bloodPressure);
    if ( temperature != null )           vitalsObservations.add( temperature);
    if ( respiratoryRate != null )       vitalsObservations.add( respiratoryRate );
    
    if ( vitalsObservations != null && !vitalsObservations.isEmpty()) {
      ObservationsPanel panel = createObservationsPanel(pJCas, pSection, panelName, vitalsObservations, eventDate);
      for ( Annotation observation_ : vitalsObservations )
        ((Observation) observation_).setParent( panel.getPanelName());
      }
    
    
  } //end Method processVitalsFormat1() --------------
  
//=================================================
 /**
  * processVitalsFormat1 this is the format where the vitals
  * names are on one line, and values are on the next line.
  * In coluumns.
  * 
  * @param pJCas
  * @param panelName 
  * @param lines 
  * @param pSection
 */
 // =================================================
 @SuppressWarnings("unused")
private final void processVitalsFormat3(JCas pJCas, List<Annotation> pLines, String panelName, Annotation pSection) {
   // parse the second line 
   //    absorb Absolute Date
   //    absorb Absolute Time
   //    absorb Height - the next number
   //    absorb weight - the next number 
   //    absorb bmi    - the next number 
   //    absorb Pulse Rate
   //    absorb blood pressure 2 numbers and a unit of measure
   //    absorb Temperature  a number and unit of measure
   //    absorb respiratory rate number and unit of measure
   
   // iterate through the lines until you get to the line after
   // the header
 
   Annotation payloadLine = getHeaderAndPayloadLine(pJCas, pLines );
  
   if ( payloadLine == null ) return;

   int  lineEnd = payloadLine.getEnd();
   int  startPosition = payloadLine.getBegin();
   Annotation eventDate             = getEventDate(          pJCas,                             payloadLine);                        if ( eventDate != null )             startPosition = eventDate.getEnd() ;
   Annotation eventTime             = getEventTime(          pJCas,                             payloadLine);                        if ( eventTime != null )             startPosition = eventTime.getEnd() ;
   Annotation height                = getNumber( pJCas, HEIGHT_LOINC_TEST_NAME,               startPosition, lineEnd, eventDate);  if ( height != null )                startPosition = height.getEnd() ;
   Annotation weight                = getNumber( pJCas, WEIGHT_LOINC_TEST_NAME,               startPosition, lineEnd, eventDate);  if ( weight != null )                startPosition = weight.getEnd() ;
   Annotation bmi                   = getNumber( pJCas, BMI_LOINC_TEST_NAME,                  startPosition, lineEnd, eventDate);  if ( bmi != null )                   startPosition = bmi.getEnd() ; // <---- see note below
   Annotation pulseRate             = getNumber( pJCas, PULSE_RATE_LOINC_TEST_NAME,           startPosition, lineEnd, eventDate);  if ( pulseRate != null )             startPosition = pulseRate.getEnd() ;
  
   Annotation bloodPressureDistolic = getNumber(        pJCas, DIOSTOLIC_LOINC_TEST_NAME,            startPosition, lineEnd, eventDate);  if ( bloodPressureDistolic != null ) startPosition = bloodPressureDistolic.getEnd() ;
   Annotation bloodPressureSystolic = getNumber(        pJCas, SYSTOLIC_LOINC_TEST_NAME,             startPosition, lineEnd, eventDate);  if ( bloodPressureSystolic != null ) startPosition = bloodPressureSystolic.getEnd() ;
  // Annotation bloodPressureUnit     = getUnitOfMeasure( pJCas,                                  startPosition, lineEnd );            if ( bloodPressureUnit != null )     startPosition = bloodPressureUnit.getEnd() ;
   Annotation bloodPressure         = createBloodPressureObserevation( pJCas, bloodPressureDistolic, bloodPressureSystolic, bloodPressureSystolic, eventDate );
   
   Annotation temperature           = getNumberAndUnit( pJCas, TEMPERATURE_LOINC_TEST_NAME,          startPosition, lineEnd, eventDate);  if ( temperature != null )           startPosition = temperature.getEnd() ;
   Annotation respiratoryRate       = getNumberAndUnit( pJCas, RESPIRATORY_RATE_LOINC_TEST_NAME,     startPosition, lineEnd, eventDate);  if ( respiratoryRate != null )       startPosition = respiratoryRate.getEnd() ;
  
   
   // note:  the +2 is needed to move the parser beyond the ((2) part of the kg/meter(2) unit of measure - the unit of measure scanner 
   //        does not currently pick up the (2) part as currently configured, even if kg/meter(2) is a local synonym 
   
   List<Annotation> vitalsObservations = new ArrayList<Annotation>( 10 );
   if ( height != null )                vitalsObservations.add( height);
   if ( weight != null )                vitalsObservations.add( weight );
   if ( bmi != null )                   vitalsObservations.add( bmi);
   if ( pulseRate != null )             vitalsObservations.add( pulseRate);
   if ( bloodPressure != null )         vitalsObservations.add( bloodPressure);
   if ( temperature != null )           vitalsObservations.add( temperature);
   if ( respiratoryRate != null )       vitalsObservations.add( respiratoryRate );
   
   if ( vitalsObservations != null && !vitalsObservations.isEmpty()) {
     ObservationsPanel panel = createObservationsPanel(pJCas, pSection, panelName, vitalsObservations, eventDate);
     for ( Annotation observation_ : vitalsObservations )
       ((Observation) observation_).setParent( panel.getPanelName());
     }
   
   
 } //end Method processVitalsFormat1() --------------

  // =================================================
  /**
   * createBloodPressureObservation makes an observation out of the distolic and systolic readings found
   * 
   * removes the blood pressure systolic and distolic 
   * 
   * @param pJCas
   * @param bloodPressureDistolic
   * @param bloodPressureSystolic
   * @param bloodPressureUnit
   * @return VitalsObservation
  */
  // =================================================
  private Annotation createBloodPressureObserevation(JCas pJCas, Annotation bloodPressureDistolic, Annotation bloodPressureSystolic, Annotation bloodPressureUnit, Annotation pEventDate) {
    
    Annotation returnVal = null;
    String testName = "blood pressure";
    String testRange = null;
    String testComment = null;
    String testInterpretation = null;
    
    if ( bloodPressureDistolic != null && bloodPressureSystolic != null ) {
      String testValue = pJCas.getDocumentText().substring(bloodPressureDistolic.getBegin(), bloodPressureUnit.getEnd());
    
      returnVal = createVitalsObservation( pJCas, testName, testValue, testRange, testComment, testInterpretation, bloodPressureDistolic.getBegin(), bloodPressureUnit.getEnd(), pEventDate );
    
      bloodPressureDistolic.removeFromIndexes();
      bloodPressureSystolic.removeFromIndexes();
    }
    
    return returnVal;
  } // end Method createBloodPressure() --------------

  // =================================================
  /**
   * getPayloadLine returns the line that has the vitals numbers in it
   * This method will also make test names if they get found
   * 
   * @param pJCas
   * @param pLines
   * @return Annotation
  */
  // =================================================
  private final Annotation getHeaderAndPayloadLine(JCas pJCas, List<Annotation> pLines) {
  
    Annotation line = null;
    Annotation returnVal = null;
    for ( int i = 0; i < pLines.size(); i++ ) {
      line = pLines.get(i);
      String buff = line.getCoveredText();
      if ( buff != null && buff.trim().length() > 0  && buff.toLowerCase().contains("height") && buff.toLowerCase().contains("pulse")) {
        
        // create test names with this line ( look for 
        createTestNames ( pJCas, line);
        if ( i < pLines.size() -1)
          returnVal = pLines.get(i + 1);
        break;
      }    
     }
     if ( returnVal == null || returnVal.getCoveredText().trim().length() == 0 ) {
       for ( int i = 0; i < pLines.size(); i++ ) {
         line = pLines.get(i);
         String buff = line.getCoveredText();
         if ( buff != null && buff.trim().length() > 0  && buff.toLowerCase().contains("f") && buff.toLowerCase().contains("min")) {
           returnVal = line;
           break;
         }    
        }
     }
     return returnVal;
  } // end Method getPayloadLine() -------------------

  // =================================================
  /**
   * createTestNames 
   * 
   * @param pJCas
   * @param pLine
  */
  // =================================================
  private final void createTestNames(JCas pJCas, Annotation pLine) {
   
    List<Annotation> terms = UIMAUtil.getAnnotationsBySpan(pJCas, LexicalElement.typeIndexID, pLine.getBegin(), pLine.getEnd() );
    
    if ( terms != null ) 
      for ( Annotation term : terms ) {

        String semanticTypes = ((LexicalElement) term ).getSemanticTypes();
        if ( semanticTypes != null && semanticTypes.contains("VitalsTestName"))
          createTestName( pJCas, term);
      }
   
  } // end Method createTestNames() ------------------

  // =================================================
  /**
   * createTestName creates a test name
   * 
   * @param pJCas
   * @param pTerm
  */
  // =================================================
 private void createTestName(JCas pJCas, Annotation pTerm) {
   TestName statement = new TestName( pJCas);
   statement.setBegin( pTerm.getBegin());
   statement.setEnd(    pTerm.getEnd());
   statement.setId(  "VitalsAnnotator_" + this.annotationCounter++);
   statement.addToIndexes();
   
    
  } // end Method createTestName() -------------------

  // =================================================
  /**
   * processVitalsFormat2 this is a format where each vital is on it's own line
   * 
   * @param pJCas
   * @param lines 
   * @param panelName 
   * @param pSection
  */
  // =================================================
  private final void processVitalsFormat2(JCas pJCas, List<Annotation> lines, String panelName, Annotation pSection) {

    List<Annotation> observations = new ArrayList<Annotation> ();
    
    Annotation eventDate = null;
    Annotation observation = null;
    for (int i = 0; i < lines.size(); i++ ) {
        eventDate = getEventDate( pJCas, lines.get(i));
        if ( ( observation = processObservation( pJCas, lines.get(i), eventDate ) )!= null )
            observations.add( observation );
      }
      
      if ( observations != null && !observations.isEmpty()) {
      ObservationsPanel panel =
          createObservationsPanel(pJCas, pSection, panelName, observations, eventDate);
         for ( Annotation observation_ : observations )
           ((Observation) observation_).setParent( panel.getPanelName());
      }
    
  }

  // =================================================
  /**
   * createObservationsPanel 
   * 
   * @param pJCas
   * @param pSection
   * @param pPanelName
   * @param pObservations
   * @param pEventDate
   * @return ObservationsPanel
  */
  // =================================================
  private ObservationsPanel createObservationsPanel(JCas pJCas, Annotation pSection,
    String pPanelName, List<Annotation> pObservations, Annotation pEventDate) {
   
   VitalsObservationsPanel statement = new VitalsObservationsPanel( pJCas);
   
   String eventDate = null;
   String clinicalStatus = null;
    if (pEventDate != null)
      eventDate = pEventDate.getCoveredText();
   
   statement.setBegin(  pSection.getBegin() );
   statement.setEnd(    pSection.getEnd());
   statement.setId( "VitalsAnnotator_" + this.annotationCounter++);
   statement.setAssertionStatus("asserted");
   statement.setPanelName( pPanelName);
   statement.setObservations(  UIMAUtil.list2FsArray(pJCas, pObservations));
   statement.setEventDate(  eventDate );
   statement.setStatementDate( eventDate);
   statement.setClinicalStatus( clinicalStatus );
   statement.setComments( null); // [TBD]
   
   statement.addToIndexes();
   return statement;
   
  } // end Method createObservationsPanel () ---------

  // =================================================
  /**
   * processObservation looks for a test, value, range
   * 
   * This method will return null if there are no tabs in the line
   *  
   * look for the following in the following columns first column should be a
   * test name second column should have a number value or a short string like a
   * color or value like clear The third column might have an event date in it -
   * it has already been absorbed and passed in
   * 
   * we may need to test to see that the values are what they say they are Look
   * the test name up in Loinc -
   * 
   *  
   * 
   * @param pJCas
   * @param pLine
   * @param pEventDate
   * @return Observation  
  */
  // =================================================
  private VitalsObservation processObservation(JCas pJCas, Annotation pLine, Annotation pEventDate) {
   
    VitalsObservation observation = null;
    String lineText = pLine.getCoveredText();
   
    String testName = null;
    String testValue = null;
    String testComment = null;
    String testRange = null;
    String testInterpretation = null;
    int testValueOffset = -1;
  
    if (lineText == null || lineText.trim().length() == 0 || !lineText.contains("\t"))
      return null;
   
    String cols[] = U.split( lineText, "\t") ;
    if ( cols.length > 1) {
       testName = cols[0].trim();
       if ( cols[1] != null ) {
         testValueOffset = pLine.getBegin() + cols[0].length() + 1;
         testValue = cols[1].trim();
        
       }
    } 
    
    observation = createVitalsObservation( pJCas, testName, testValue, testRange, testComment, testInterpretation, pLine.getBegin(), pLine.getEnd(), pEventDate );
    
    
    // create testName
    // create testValue
    // create testRange
    // create testComment
    // create testInterpretation
    createObservationEvidence(pJCas, TestName.class, pLine.getBegin(), pLine.getBegin() + testName.length(), observation);
    createObservationEvidence(pJCas, TestValue.class, testValueOffset, testValueOffset + testValue.length(), observation);
   
    return observation;
  } // end Method processObservation() ---------------
  
  // =================================================
  /**
   * createVitalsObservation creates an Observation 
   *  
   * 
   * @param pJCas
   * @param pTestName
   * @param pTestValue
   * @param pTestRange
   * @param pTestComment
   * @param pTestInterpretation
   * @param pBeginOffset
   * @param pEndOffset
   * @param pEventDate
   * @return VitalsObservation  
  */
  // =================================================
  private VitalsObservation createVitalsObservation(JCas pJCas, String pTestName, String pTestValue, String pTestRange, String pTestComment, String pTestInterpretation, int pBeginOffset, int pEndOffset,  Annotation pEventDate) {
   
    
    VitalsObservation statement = new VitalsObservation(pJCas) ;
    
    String eventDate = null;
    if ( pEventDate != null )
      eventDate = pEventDate.getCoveredText();
    
    statement.setBegin( pBeginOffset );
    statement.setEnd(   pEndOffset);
    statement.setTestName(  pTestName);
    statement.setTestValue( pTestValue);
    statement.setResultRange( pTestRange );
    statement.setComment( pTestComment);
    statement.setEventDate(  eventDate );
    statement.setInterpretation( pTestInterpretation);
    statement.addToIndexes();
 
    return statement;
  } // end createVitalsObservation() -----------------

  // =================================================
  /**
   * createObservationEvidence creates an ObservationEvidence tied back to the
   * panel
   * 
   * @param pJCas
   * @param pClassName
   * @param pBeginOffset
   * @param pEndoffset
   * @param pParentPanel
  */
  // =================================================
  private final void createObservationEvidence(JCas pJCas, Class<?> pClassName, int pBeginOffset, int pEndOffset, Annotation pParentPanel) {
    
    try {
      Constructor<?> c = pClassName.getConstructor(new Class[] {
          JCas.class
      });
      Object statement = c.newInstance(pJCas);

      ((ObservationEvidence) statement).setBegin(pBeginOffset);
      ((ObservationEvidence) statement).setEnd(pEndOffset);
      ((ObservationEvidence) statement).setId("LabPanelAnnotator_" + annotationCounter++);
      ((ObservationEvidence) statement).setParentPanel( pParentPanel);
      ((ObservationEvidence) statement).addToIndexes(pJCas);

    } catch (Exception e) {
      e.printStackTrace();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "createObservationEvidence",
          "Something went wrong here " + e.toString());
    }
 
  } // end Method createObservationEvidence() -------

  // =================================================
  /**
   * createClinicalStatus.
   * 
   * @param pJCas the j cas
   * @param pTerm the term
   * @return ClinicalStatusEvidence
  */
  // =================================================
  @SuppressWarnings("unused")
   private final Annotation createClinicalStatus(JCas pJCas, Annotation pTerm) {
     ClinicalStatusEvidence statement = new ClinicalStatusEvidence(pJCas );
     statement.setBegin( pTerm.getBegin());
     statement.setEnd(  pTerm.getEnd() );
     statement.addToIndexes();
  return statement;
  } // end Method createClinicalStatus() -----------

  // =================================================
  /**
   * getEventDate retrieves the event date tagged at the top of the panel. This
   * looks for a date on the line that has the header or if not found the next
   * line
   * 
   * This method creates an eventDate annotation
   * 
   * @param pJCas
   * @param pLine
   * @return Annotation
   */
  // =================================================
  private final Annotation getEventDate(JCas pJCas, Annotation pLine) {

    Annotation returnVal = null;
    Annotation aDate = null;
    List<Annotation> eventDates = UIMAUtil.getAnnotationsBySpan(pJCas, AbsoluteDate.typeIndexID, pLine.getBegin(), pLine.getEnd());

    if (eventDates != null && !eventDates.isEmpty()) {
      aDate = eventDates.get(0);
      returnVal = createEventDate( pJCas, aDate );
      
    }
    return returnVal;
  } // end Method getEventDate() -------------------
  
// =================================================
  /**
   * createEventDate 
   * 
   * The side effect of this is that the pDate is
   * removed from the index
   * 
   * @param pJCas
   * @param pDate
   * @return EventDate
  */
  // =================================================
  private final Annotation createEventDate(JCas pJCas, Annotation pDate) {
    EventDate statement = new EventDate( pJCas);
    statement.setBegin(  pDate.getBegin());
    statement.setEnd( pDate.getEnd() );
    statement.setId("VitalsAnnotator_" + this.annotationCounter++);
    statement.addToIndexes();
    
    pDate.removeFromIndexes();
    
    
    return statement;
  }

//=================================================
 /**
  * getEventTime retrieves the event time
  * 
  * @param pJCas
  * @param pLine
  * @return Annotation
  */
 // =================================================
 private final Annotation getEventTime(JCas pJCas, Annotation pLine) {

   Annotation returnVal = null;
   List<Annotation> eventDates = UIMAUtil.getAnnotationsBySpan(pJCas, AbsoluteTime.typeIndexID, pLine.getBegin(), pLine.getEnd());

   if (eventDates != null && !eventDates.isEmpty())
     returnVal = eventDates.get(0);
   return returnVal;
 } // end Method getEventTime() -------------------
 
  

  // =================================================
  /**
   * getNumberAndUnit finds the next number and unit in the
   * line, and returns an observation with the designated
   * type
   * 
   * @param pJCas
   * @param pTestName
   * @param pBeginOffset
   * @param pEndOffset
   * @param pEventDate
   * @return VitalsObservation
   */
  // =================================================
  private final VitalsObservation getNumberAndUnit(JCas pJCas, String pTestName, int pBeginOffset, int pEndOffset, Annotation pEventDate) {

    VitalsObservation returnVal = null;
    Annotation aNumber = null;
    Annotation aUnitOfMeasure = null;
    String testValue = null;
    String testRange = null;
    String testComment = null;
    String testInterpretation = null;
    
    
    List<Annotation> nextNumbers = UIMAUtil.getAnnotationsBySpan(pJCas, Number.typeIndexID, pBeginOffset, pEndOffset );
    
    if ( nextNumbers != null && !nextNumbers.isEmpty() ) {
      aNumber = nextNumbers.get(0);
      
      List<Annotation> nextUnitOfMeasure = UIMAUtil.getAnnotationsBySpan(pJCas, UnitOfMeasure.typeIndexID, aNumber.getEnd(), pEndOffset );
      
      if ( nextUnitOfMeasure != null && !nextUnitOfMeasure.isEmpty()) {
         aUnitOfMeasure = nextUnitOfMeasure.get(0);
    
         testValue = pJCas.getDocumentText().substring(aNumber.getBegin(), aUnitOfMeasure.getEnd());
        
         returnVal = createVitalsObservation( pJCas, pTestName, testValue, testRange, testComment, testInterpretation, aNumber.getBegin(), aUnitOfMeasure.getEnd(), pEventDate );
         
         
      }
    }

   
    
    return returnVal;
  } // end Method getNumberAndUnit() -----------------
  
  

  // =================================================
  /**
   * getNumber finds the next number and unit in the
   * line, and returns an observation with the designated
   * type
   * 
   * @param pJCas
   * @param pTestName
   * @param pBeginOffset
   * @param pEndOffset
   * @param pEventDate
   * @return VitalsObservation
   */
  // =================================================
  private final VitalsObservation getNumber(JCas pJCas, String pTestName, int pBeginOffset, int pEndOffset, Annotation pEventDate) {

    VitalsObservation returnVal = null;
    Annotation aNumber = null;
  
    String testValue = null;
    String testRange = null;
    String testComment = null;
    String testInterpretation = null;
    
    
    List<Annotation> nextNumbers = UIMAUtil.getAnnotationsBySpan(pJCas, Number.typeIndexID, pBeginOffset, pEndOffset );
    
    if ( nextNumbers != null && !nextNumbers.isEmpty() ) {
      aNumber = nextNumbers.get(0);
      testValue = aNumber.getCoveredText();
      returnVal = createVitalsObservation( pJCas, pTestName, testValue, testRange, testComment, testInterpretation, aNumber.getBegin(), aNumber.getEnd(), pEventDate );
  
    }

    return returnVal;
  } // end Method getNumber() ------------------------
  

  // =================================================
  /**
   * getUnitOfMeasure finds the next unit of measure and returns
   * this annotation
   * 
   * @param pJCas
   * @param pBeginOffset
   * @param pEndOffset
   * @param pEventDate
   * @return Annotation
   */
  // =================================================
  private final Annotation getUnitOfMeasure(JCas pJCas, int pBeginOffset, int pEndOffset ) {

    Annotation returnVal = null;
   
    List<Annotation> units = UIMAUtil.getAnnotationsBySpan(pJCas, UnitOfMeasure.typeIndexID, pBeginOffset, pEndOffset );
    
    if ( units != null && !units.isEmpty() )
      returnVal = units.get(0);
      

    return returnVal;
  } // end Method getUnitOfMeasure() ------------------------
  
  
  

  // =================================================
  /**
   * getVitalsSectionSections
   * 
   * @param pJCas
   * @return List<Annotation>
   */
  // =================================================
  private final List<Annotation> getVitalsSectionSections(JCas pJCas) {

    List<Annotation> vitalsSections = null;
    List<Annotation> sections = UIMAUtil.getAnnotations(pJCas, SectionZone.typeIndexID);

    if (sections != null && !sections.isEmpty()) {
      vitalsSections = new ArrayList<Annotation>();
      for (Annotation section : sections) {
        if ( section != null ) {
        String sectionName = ((SectionZone) section).getSectionName();
        if (sectionName != null && (
            sectionName.toLowerCase().contains("vital")) )
          vitalsSections.add(section);
        }
      }
    }
    return vitalsSections;
  } // end Method getVitalsSectionSections() --------
  
  //----------------------------------
  /**
   * initialize.
   * 
   * @param aContext the a context
   * @throws ResourceInitializationException the resource initialization
   *           exception
   */
  // ----------------------------------
  @Override
  public void initialize(UimaContext aContext) throws ResourceInitializationException {
    
    String[] args = null;
    try {
      args                 = (String[]) aContext.getConfigParameterValue("args");  
      
      initialize( args );
      
    } catch (Exception e ) {
      e.printStackTrace();
      String msg = "Issue initializing " + this.getClass().getSimpleName() + " " + e.toString() ;
      GLog.println(GLog.ERROR_LEVEL, msg);
      throw new ResourceInitializationException();
    }
    
  } // end Method initialize() --------

  // ----------------------------------
  /**
   * initialize initializes the class. Parameters are passed in via a String
   * array with each row containing a --key=value format.
   * 
   * It is important to adhere to the posix style "--" prefix and include a
   * "=someValue" to fill in the value to the key.
   * @param pArgs
   * @throws ResourceInitializationException
   * 
   **/
  // ----------------------------------
  public void initialize(String[] pArgs) throws ResourceInitializationException {

    try {

      this.performanceMeter = new ProfilePerformanceMeter(pArgs, this.getClass().getSimpleName());
   
      this.termLookup = TermLookupFactory.getTermLookup( pArgs );
     
      
      HEIGHT_LOINC_TEST_NAME             = lookupCode ( "LNC", "body height" );          
      WEIGHT_LOINC_TEST_NAME             = lookupCode ( "LNC", "body weight");               
      BMI_LOINC_TEST_NAME                = lookupCode ( "LNC", "bmi");
      PULSE_RATE_LOINC_TEST_NAME         = lookupCode ( "LNC", "heart rate");
      DIOSTOLIC_LOINC_TEST_NAME          = lookupCode ( "LNC", "diastolic blood pressure");
      SYSTOLIC_LOINC_TEST_NAME           = lookupCode ( "LNC", "systolic blood pressure");
     //  BLOODPressure_UNIT_UCUM_Code  = "mmHg";
      TEMPERATURE_LOINC_TEST_NAME        = lookupCode ( "LNC", "body temperature");
      RESPIRATORY_RATE_LOINC_TEST_NAME   = lookupCode ( "LNC", "respiratory rate");


    } catch (Exception e) {
      e.printStackTrace();
      String msg = "Issue initizlizng labPanel Annotator " + e.toString();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "initialize", msg);
      throw new ResourceInitializationException();
    }
  } // end Method initialize() -------

  // =================================================
  /**
   * lookupCode returns the term:sourceTerminology:sourceId 
   * for this term 
   * 
   * Returns the first "LR" coded result if there is one
   * or the first of what comes back otherwise.
   *
   * @param pTerminology the terminology
   * @param pTerm the term
   * @return String
   * @throws Exception the exception
   */
  // =================================================
  @SuppressWarnings("unused")
  private final String lookupCode(String pTerminology, String pTerm) throws Exception  {
    String returnVal = null;
    try {
      String[]lragrRows = this.termLookup.getNotThatSimple(pTerminology, pTerm);
      
      if ( lragrRows != null && !lragrRows.isEmpty() )
        for ( LRAGRRow row : lragrRows ) {
          if ( row.getSourceId().startsWith("LR" )) {
              returnVal = row.getName() + ":" + row.getTerminology() + ":" + row.getSourceId() + ":" + row.getCuis() + ":" + row.getSemanticTypes() ;
              break;
          }
          if ( returnVal == null ) {
            row = lragrRows.get(0);
            returnVal = row.getName() + ":" + row.getTerminology() + ":" + row.getSourceId() + ":" + row.getCuis() + ":" + row.getSemanticTypes() ;
        
          }
        }
      
    } catch (Exception e) {
      e.printStackTrace();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "lookupCode", "Issue looking up the loinc codes " + e.toString());
    }
    
    return returnVal;
    
  }

  // ---------------------------------------
  // Global Variables
  // ---------------------------------------
  protected int annotationCounter = 0; // new Term Counter.

  private ProfilePerformanceMeter performanceMeter = null;
  
  private static String HEIGHT_LOINC_TEST_NAME = "body height";               
  private static String WEIGHT_LOINC_TEST_NAME = "body weight";               
  private static String BMI_LOINC_TEST_NAME = "bmi";
  private static String PULSE_RATE_LOINC_TEST_NAME = "heart rate";           
  private static String DIOSTOLIC_LOINC_TEST_NAME = "diastolic blood pressure";
  private static String SYSTOLIC_LOINC_TEST_NAME = "systolic blood pressure";
//  private static String BLOODPressure_UNIT_UCUM_Code = "mmHg";    
  private static String TEMPERATURE_LOINC_TEST_NAME = "body temperature";      
  private static String RESPIRATORY_RATE_LOINC_TEST_NAME = "respiratory rate";
  
  
  TermLookupInterface termLookup = null;

} // end Class LabPanelAnnotator() ---------------
