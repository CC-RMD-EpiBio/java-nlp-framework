// =================================================
/**
 * GeneNameLookupAnnotator
 * 
 * This is an extension to Lorretta - it only looks up
 * terms in geneObservation sections into HUGO's HGNC terminology
 *
 * @author Guy Divita
 * @created Aug 15, 2018
 * 
 */
// ================================================
package gov.nih.cc.rmd.nlp.framework.annotator.geneObservations;

import java.util.HashSet;
import java.util.List;

import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.tcas.Annotation;
import org.apache.uima.resource.ResourceInitializationException;

import com.ciitizen.framework.GeneName;
import gov.nih.cc.rmd.nlp.framework.utils.terminologies.lookup.LRAGRRow;

import gov.nih.cc.rmd.nlp.framework.annotator.loretta.LorettaAnnotator;
import gov.nih.cc.rmd.nlp.framework.annotator.loretta.TempTerm;
import gov.va.chir.model.Utterance;
import gov.nih.cc.rmd.nlp.framework.utils.GLog;
import gov.nih.cc.rmd.nlp.framework.utils.U;
import gov.nih.cc.rmd.nlp.framework.utils.framework.uima.VUIMAUtil;

public class GeneNameLookupAnnotator extends LorettaAnnotator {

  public static final String annotatorName = GeneNameLookupAnnotator.class.getSimpleName();



  // =================================================
  /**
   * getTerminologiesFromSection returns a terminology
   * based on what section this annotation is in
   * 
   * i.e., look in rxnorm if you are in a medications section
   *       look in loinc if you are in vitals, labs ... section
   *       otherwise look in snomedct_us
   * 
   * @param pJCas
   * @param pSentence
   * @return String[]
  */
  // =================================================
  @Override
  public String[] getTerminologiesFromSection(JCas pJCas, Utterance pSentence) {
    
    String[] terminologies =  this.terminologies; 
    
    return terminologies;
  } // end Method getTerminologyFromSection()----------


  // =================================================
/**
 * termLookupSimple looks up the string and attributes
 * the offsets to the sentence 
 * 
 *   This method bypasses the section filtering mechanism. 
 * @param pJCas
 * @param pSentence
 * @param pTerm
 * @return Annotation
*/
// =================================================
public Annotation termLookupSimple(JCas pJCas, Annotation pSentence, String pTerm) {
  
  Annotation returnVal = null;
  
  if ( pTerm != null )
    if ( U.split(pTerm, " ").length < 2 ) {
      if ( super.terminologyService == null) 
        System.err.println("Issuer here"); 
      List<LRAGRRow> lragrRows = super.getSimple(this.terminologies, this.tree, pTerm + " gene");
  
      if ( lragrRows != null && lragrRows.size() == 1) {
        returnVal = makeTermFromLRAGRRows( pJCas, pSentence,  lragrRows );
      } 
     
  }
  
  return returnVal;  
} // end Method termLookupSimple() -------


 // =================================================
 /**
  * makeTermFromLRAGRRow
  * 
  * 
  * @param pRows
  * @return List<Annotation>
 */
 // =================================================
  @Override
  protected Annotation makeTermFromLRAGRRows(JCas pJCas, TempTerm aTempTerm, List<LRAGRRow> pRows ) {
   
   // theres got to be some exceptions until we can take out odd gene names
    
    GeneName statement = null;
   
    statement = new GeneName(pJCas);
  
  List<Annotation> tokens = aTempTerm.getRealTokens();
   if ( tokens == null || tokens.isEmpty()) {
     GLog.println(GLog.ERROR_LEVEL, "Issue with term with no aligned tokens " );
     return null;
   }
   int beginOffset = tokens.get(0).getBegin();
   int endOffset   = tokens.get(tokens.size() -1).getEnd();
 
   String cuis = LRAGRRow.getCuis( pRows ); 
   String conceptNames = LRAGRRow.getConceptNames( pRows);
   String semanticTypes = LRAGRRow.getSemanticTypes( pRows);
  
   statement.setBegin( beginOffset);
   statement.setEnd(    endOffset );
   statement.setId("GeneNameLookup_" + annotationCounter );
   statement.setCuis(cuis);
   statement.setCategories(semanticTypes);
   statement.setConceptNames(conceptNames);
   
   String geneName = statement.getCoveredText();
   if ( oddGeneName( geneName) ) 
     return null;
 
   if ( isInContentHeading( pJCas, statement ))
     return null;
   if ( isInOtherConcept(   pJCas, statement ))
     return null;
   
   
   //   0        1     2      3     4    5     6    7    8    9 10|11|12|13|4
   // C1519530|title|<noun>|<all>|Title|Title|T078|NCI|C19067|n|0 |S |PF|title|1
   
   StringBuffer buff = new StringBuffer();
   for ( LRAGRRow row : pRows )
     buff.append( row.toLRAGRString() + ":");
   
  statement.setOtherInfo( buff.toString());
  
  
   statement.addToIndexes();
   String sectionName = VUIMAUtil.deriveSectionName(statement);
   statement.setSectionName(sectionName);
   
    
   return statement;
   
   
 } // end Method makeTermFromLRAGRRow() -------------



  // =================================================
  /**
   * makeTermFromLRAGRRow
   * 
   * @param pJCas
   * @param pTerm
   * @param pRows
   * @return List<Annotation>
   */
  // =================================================
  protected Annotation makeTermFromLRAGRRows(JCas pJCas, Annotation pTerm,  List<LRAGRRow> pRows) {

    GeneName statement = new GeneName(pJCas);

   
    int beginOffset = pTerm.getBegin();
    int endOffset = pTerm.getEnd();

    String cuis = LRAGRRow.getCuis(pRows);
    String conceptNames = LRAGRRow.getConceptNames(pRows);
    String semanticTypes = LRAGRRow.getSemanticTypes(pRows);
   
    statement.setBegin(beginOffset);
    statement.setEnd(endOffset);
    statement.setId  ("SpecimenSiteLookup_" + annotationCounter);
    statement.setCuis(cuis);
    statement.setCategories(semanticTypes);
    statement.setConceptNames(conceptNames);

    
    // 0 1 2 3 4 5 6 7 8 9 10|11|12|13|4
    // C1519530|title|<noun>|<all>|Title|Title|T078|NCI|C19067|n|0 |S |PF|title|1

    StringBuffer buff = new StringBuffer();
    for (LRAGRRow row : pRows)
      buff.append(row.toLRAGRString() + ":");

    statement.setOtherInfo(buff.toString());

    statement.addToIndexes();
    String sectionName = VUIMAUtil.deriveSectionName(statement);
    statement.setSectionName(sectionName);


    return statement;

  } // end Method makeTermFromLRAGRRow() -------------



  // =================================================
/**
 * oddGeneName returns true if this term is not an 
 * odd gene name
 * 
 * @param pGeneName
 * @return boolean
*/
// =================================================
private boolean oddGeneName(String pGeneName ) {
  boolean returnVal = false;
  
  // single letter gene names
  if (pGeneName.trim().length() == 1 )
    returnVal = true;
  else if ( this.oddGeneNames.contains( pGeneName.trim().toLowerCase() ) )
    returnVal = true;
  
  return returnVal;
} // end notException() -----------------------------



  //----------------------------------
  /**
   * initialize initializes the class.  Parameters are passed in via a String
   *                array  with each row containing a --key=value format.
   *                
   *                It is important to adhere to the posix style "--" prefix and
   *                include a "=someValue" to fill in the value to the key. 
   * @param pArgs
   * @throws  ResourceInitializationException            
   * 
   **/
  // ----------------------------------
  public void initialize(String[] pArgs) throws ResourceInitializationException {
       
    super.initialize( pArgs);
    
    super.terminologies  = new String[1] ;
    super.terminologies[0] = "HGNC";
    GLog.println(GLog.DEBUG_LEVEL, this.getClass(), "initialize", "New improved gene name lookup tool!");
    
    // -------------------------
    // Set this to the annotation type being created in this class
    // -------------------------
    this.annotationType = "GeneName";
    
    try {
   
      this.oddGeneNames.add( "in");
      this.oddGeneNames.add("type");
      this.oddGeneNames.add("gen");
      this.oddGeneNames.add("2+");
      this.oddGeneNames.add("for");
      
  
    } catch (Exception e) {
      e.printStackTrace();
      String msg = "Issue initizlizng Loretta " + e.toString();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "initialize", msg);
      throw new ResourceInitializationException();
    }
  } // end Method initialize() -------
  

   private HashSet<String> oddGeneNames = new HashSet<String>();

} // end Class ExampleAnnotator() ---------------
