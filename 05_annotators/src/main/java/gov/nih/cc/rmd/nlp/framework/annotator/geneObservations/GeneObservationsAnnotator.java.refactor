// =================================================
/**
 * Gene Observations Annotator will find gene observations 
 * 
 * each gene observation will have the following attributes
 * 
 *  the gene               (terminology lookup)
 *  the gene Variant,      (regex/Enumerations)
 *  the gene variant value percent  (% value)
 *  medication(s) of interest ( terminology lookup)
 *  
 *  These correspond to columns in gene report tables
 *
 *  The format for the tables to extract from include
 *  
 *   For molpath-foundation-one Theraputic Implications table with the following column headings
 *   
 *   Genomic Alterations Detected | FDA Approved Therapies | FDA Approved Therapies | Potential Clinical Trials
 *   
 *   PIK3CA  <-- gene               none                     Everolimus                Yes
 *   H1047R  <-- gene variant                                Temsirolimus         
 *   
 *   
 *   In guardant360 kinds of reports
 *   
 *   Summary of Alterations & associated Treatment Options
 *   
 *   Alteration __   %cfDNA      cfDNA Amplification   FDA Approved in Indication  Available for Use in Other Indications  Clinical Drug Trials
 *  
 *   EGFR       L858R  29.5         _                          Afatinib                    None                             Trials Available
 *              AMP                 ++                         None                    Afatnib
 *                                                                                     Cetuximab
 *  
 *  
 *   Variants of unknown significance
 *   CDk1                  PALB2         TNFAIP3
 *   amplification         T397S         T647P
 *  
 *  
 *  in the mayo clinic 
 *     gene: xxxx
 *     DNA change: 
 *     Amino Acid Change: 
 *     Classification  mutation
 *     
 *     Variant of uncertain cignificance
 *  
 *  
 * @author  Guy Divita 
 * @created Jun 1, 2018
 *
 * 
 * 

 */
// ================================================
package gov.nih.cc.rmd.nlp.framework.annotator.geneObservations;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;

import org.apache.uima.UimaContext;
import org.apache.uima.analysis_component.JCasAnnotator_ImplBase;
import org.apache.uima.analysis_engine.AnalysisEngineProcessException;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.tcas.Annotation;
import org.apache.uima.jcas.tcas.DocumentAnnotation;
import org.apache.uima.resource.ResourceInitializationException;

import com.ciitizen.Medication;
import com.ciitizen.framework.Diagnosis;
import com.ciitizen.framework.GeneName;
import com.ciitizen.framework.GeneObservation;
import com.ciitizen.framework.GeneVariantObservation;
import com.ciitizen.framework.SectionZone;
import com.ciitizen.framework.SpecimenSite;
import com.ciitizen.framework.TableRow;
import com.ciitizen.framework.TestInterpretation;
import com.ciitizen.framework.TestMethod;
import com.ciitizen.framework.TestName;
import com.ciitizen.framework.TestValue;
import com.ciitizen.framework.model.Shape;
import com.ciitizen.framework.model.UnitOfMeasure;

import gov.nih.cc.rmd.nlp.framework.annotator.loretta.SectionMetaInfo;
import gov.va.chir.model.ContentHeading;
import gov.va.chir.model.LexicalElement;
import gov.va.chir.model.Line;
import gov.va.chir.model.Sentence;
import gov.va.vinci.model.Concept;
import gov.va.vinci.model.temporal.CollectionDate;
import gov.nih.cc.rmd.nlp.framework.utils.GLog;
import gov.nih.cc.rmd.nlp.framework.utils.ProfilePerformanceMeter;
import gov.nih.cc.rmd.nlp.framework.utils.U;
import gov.nih.cc.rmd.nlp.framework.utils.framework.uima.VUIMAUtil;
import gov.nih.cc.rmd.nlp.framework.utils.uima.UIMAUtil;



public class GeneObservationsAnnotator extends GeneNameLookupAnnotator  {
 

  private SectionMetaInfo sectionInfo;
  // -----------------------------------------
  /**
   * process retrieves lines of the document, labels those that are questions
   * as QuestionAndAnswer elements.
   * 
   * 
   */
  // -----------------------------------------
  @Override
  public void process(JCas pJCas) throws AnalysisEngineProcessException {
   
    try {
    this.performanceMeter.startCounter();
    
    gov.va.chir.model.DocumentHeader documentHeader = VUIMAUtil.getDocumentHeader(pJCas);
    String sectionName = documentHeader.getSectionType();
    String documentType = documentHeader.getDocumentType();
    
    if ( documentType == null )  return;
    if ( documentType != null ) 
      if ( documentType.equals("Genetic analysis summary report") ||
           documentType.contains("ngs") ) {                                  //<---- so I can do testing with files
    
    
    if ( sectionName != null ) {
      
      if ( this.sectionInfo.isValidSectionFor(sectionName, "GeneObservation")) {
        
        Annotation docAnnotation = UIMAUtil.getAnnotation( pJCas, DocumentAnnotation.typeIndexID );
        processGeneSection( pJCas, docAnnotation );
      }
      
    } else {
    // Iterate through the geneObservation sections
    
    List<Annotation> sections = UIMAUtil.getAnnotations(pJCas, SectionZone.typeIndexID );
    
    if (sections != null && !sections.isEmpty()) {
      
      for ( Annotation section : sections) {
        String sectionType = ((SectionZone) section ).getSectionTypes();
        String annotationTypes = ((SectionZone) section).getAnnotationTypes();
        
        if ( sectionType != null && sectionType.toLowerCase().contains("genesectionname")  && annotationTypes != null && !annotationTypes.contains("none"))
        
        {
          processGeneSection( pJCas, section );
          
        }
      }
    } 
    }
    
    // repair part
    // remove gene observations and components that are in table rows that also contain contentHeadings
    repairGeneObservations( pJCas);
    
    addSpecimenCollectedDate_Site_Diagnosis_ToObservations( pJCas);
   
      }
    this.performanceMeter.stopCounter();
    
    } catch (Exception e) {
      e.printStackTrace();
      System.err.println("Issue with " + this.getClass().getName() + " " + e.toString());
   //   throw new AnalysisEngineProcessException();
    }
  } // end Method process() ----------------
   
  
 // =================================================
  /**
   * processGeneSection 
   * 
   * @param pSection
   * @return List<Annotation>
  */
  // =================================================
  private final List<Annotation> processGeneSection(JCas pJCas, Annotation pSection) {
  
    List<Annotation >geneObservations = null;
    List<Annotation> geneObservationsBuff = null;
    // -----------------------------------
    // from the gene section, get the table rows
    List<Annotation> lines = UIMAUtil.getAnnotationsBySpan( pJCas, Line.typeIndexID, pSection.getBegin(), pSection.getEnd() );
    
    if ( lines != null && !lines.isEmpty()) {
      geneObservationsBuff = new ArrayList<Annotation>();
      ArrayList<Annotation> lineBuff = null;
      // gather the table rows for the non-empty lines
      for ( int i = 0; i < lines.size(); i++ ) {
        
        String buf = lines.get(i).getCoveredText(); 
        if ( buf == null || buf.isEmpty() || buf.trim().length() == 0 ) {
          // break between rows, process what's in the lineBuff;
          if ( lineBuff != null && !lineBuff.isEmpty() ) {
            geneObservations = processTableRows( pJCas, lineBuff);
            if ( geneObservations != null && geneObservations.isEmpty() )
              geneObservationsBuff.addAll( geneObservations );
          }
          lineBuff = null;
        } else {
          if ( lineBuff == null ) lineBuff = new ArrayList<Annotation>();
          lineBuff.add( lines.get(i));
        }        
      } // end loop through lines
      
      if ( lineBuff != null)
       geneObservations = processTableRows( pJCas, lineBuff);
      
      if ( geneObservations != null && geneObservations.isEmpty() )
        geneObservationsBuff.addAll( geneObservations );
        
      
    }
    
     
    // medication mentions in gene sections are recommendations - i.e. hypothetical - so these instances need to 
    // be marked as such - or taken out
    markMedicationInGeneSectionAsHypothetical (pJCas, pSection );
    
    
    return geneObservationsBuff;
  } // end Method processGeneSection() --------------


  // =================================================
  /**
   * addSpecimenCollectedDateToObservations if
   *  a collectionDate was found in this document
   * 
   * @param pJCas
  */
  // =================================================
  private final void addSpecimenCollectedDate_Site_Diagnosis_ToObservations(JCas pJCas) {
  
    
    List<Annotation> specimenCollected = UIMAUtil.getAnnotations(pJCas, CollectionDate.typeIndexID );
    List<Annotation> specimenSites = UIMAUtil.getAnnotations(pJCas, SpecimenSite.typeIndexID );
    List<Annotation> diagnoses = UIMAUtil.getAnnotations(pJCas, Diagnosis.typeIndexID );
    
    
    List<Annotation> geneObservations = UIMAUtil.getAnnotations(pJCas, GeneObservation.typeIndexID );
    
    if ( geneObservations != null && !geneObservations.isEmpty()) 
      for ( Annotation geneObservation : geneObservations ) {
        if ( specimenCollected != null && !specimenCollected.isEmpty())
             ((GeneObservation) geneObservation).setEventDate( specimenCollected.get(0).getCoveredText());
        
        ((GeneObservation) geneObservation).setSpecimenSite(  getConceptInfo ( specimenSites ));
        ((GeneObservation) geneObservation).setDiagnosis(  getConceptInfo (  diagnoses ));
      }
        
  } // end Method addSpecimenCollectedDate_Site_Diagnosis_ToObservations ------------
  
  
    // =================================================
  /**
   * getConceptInfo returns the covered text plus the concept info
   * 
   * @param specimenSites
   * @return String
  */
  // =================================================
  private final String getConceptInfo(List<Annotation> pConcepts) {
  
    String returnVal = null;
    
    Concept aConcept = null;
    if ( pConcepts != null && !pConcepts.isEmpty() ) {
       aConcept =  (Concept) pConcepts.get(0);
       if ( aConcept != null ) 
         returnVal = aConcept.getCoveredText() + "|" + aConcept.getOtherInfo();
       
    }
    return returnVal;
  
  } // end addSpecimenCollectedDate_Site_Diagnosis_ToObservations() ------------




// =================================================
  /**
   * repairGeneObservations 
   * 
   * @param pJCas
  */
  // =================================================
   private void repairGeneObservations(JCas pJCas) {
   
     List<Annotation> geneObservations = UIMAUtil.getAnnotations(pJCas, GeneObservation.typeIndexID );
     
     if ( geneObservations != null && !geneObservations.isEmpty()) {
       for ( Annotation geneObservation : geneObservations )
         repairGeneObservation( pJCas, geneObservation);
     }
    
  } // end Method repairGeneObservations() ---------


   // =================================================
    /**
     * repairGeneObservation finds the tableRow the observation is in
     * 
     * @param pJCas
     * @param pObservation
    */
    // =================================================
     private void repairGeneObservation(JCas pJCas, Annotation pObservation) {
     
     
       List<Annotation> headings = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas, ContentHeading.typeIndexID, pObservation.getBegin(), pObservation.getEnd() );
       if ( headings != null && !headings.isEmpty()) 
         removeGeneObservation( pJCas, pObservation );
         
          
         else {
       
       // remove gene observations that have negative findings 
       // remove gene observations that are not from ngs type
       // remove gene observations that didn't have the test performed
       // remove gene observations that no mutation was found
       
       String interpretation = ((GeneObservation) pObservation ).getInterpretation();
       String         method = ((GeneObservation) pObservation ).getMethod() ;
       if ( interpretation != null && ( 
           interpretation.toLowerCase().contains("negative") ||
           interpretation.toLowerCase().contains("mutation not detected") ||
           interpretation.toLowerCase().contains("uncertain significance") ||
           interpretation.toLowerCase().contains("not tested") ) ) 
         removeGeneObservation( pJCas, pObservation  );
       
       else if ( method != null &&
          (method.contains("ІНС") ||
           method.toLowerCase().contains("ihc") || 
           method.toLowerCase().contains("thc") ||
           method.toLowerCase().contains("fish") ||
           method.toLowerCase().contains("cish") ))
         removeGeneObservation( pJCas, pObservation  );
         
     }    
      
      
    } // end Method repairGeneObservations() ---------

   


  // =================================================
    /**
     * removeGeneObservation removes the gene name, the variant, medication and percent that
     * appears in this table row.  It's a column heading.
     * 
     * @param pObservation
    
    */
    // =================================================
   private final void removeGeneObservation(JCas pJCas, Annotation pObservation ) {
    
    
     
     List<Annotation> geneNames = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas, GeneName.typeIndexID,  pObservation.getBegin(), pObservation.getEnd());
     List<Annotation> geneVariants = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas, GeneVariantObservation.typeIndexID,  pObservation.getBegin(), pObservation.getEnd());
     List<Annotation> therapies = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas, Medication.typeIndexID,  pObservation.getBegin(), pObservation.getEnd());
      List<Annotation> percentage = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas, TestValue.typeIndexID,  pObservation.getBegin(), pObservation.getEnd());
   
     /*
     if ( geneNames != null && !geneNames.isEmpty())
       for  (Annotation geneName : geneNames )
         geneName.removeFromIndexes();
     
     if ( geneVariants != null && !geneVariants.isEmpty())
       for  (Annotation geneVariant : geneVariants)
         geneVariant.removeFromIndexes();
     
     if ( therapies != null && !therapies.isEmpty())
       for  (Annotation therapy : therapies)
         therapy.removeFromIndexes();
     */
     
   
     pObservation.removeFromIndexes(); 
     
    } // end Method removeGeneObservation() ------------







  // =================================================
  /**
   * processTableRows processes the table rows in this buff
   * 
   * @param pJCas
   * @param lineBuff
   * @return List<Annotation> 
  */
  // =================================================
  private final List<Annotation> processTableRows(JCas pJCas, List<Annotation> lineBuff) {
    
    List<Annotation> returnVal = null;
    
    
    int beginOffset = lineBuff.get(0).getBegin();
    int endOffset   = lineBuff.get( lineBuff.size() -1 ).getEnd();
    
    // look up gene names within these lines
    //   (note this used to be done in a prior separate
    //    geneLookupAnnotator - but, we are now constraining
    //    the gene name lookup to only these lines, and adding
    //    'xxx gene" to the search - this requires delaying the
    //    lookup til we've created the line boundaries 
    //    and not doing it in a separate annotator
    //    where those boundries have not yet been determined.
    //    This is the first place we know we are working
    //    with a potential gene observation within these
    //    boundaries. 
    //    
    //    If gene names were not found or too many gene names
    //    were found, this block is not valid, move on
    //        GD 09/12/18
    
    if ( findOneGeneName( pJCas, beginOffset, endOffset) ) {
    
    
      // look for an interpretation in the second line 
      if ( lineBuff.size() > 1)
        processGeneTableRowSecondLine( pJCas, lineBuff.get(1));
      
      // look for the obvious slot values
      findGeneSlotsAndValues( pJCas, lineBuff);
    
      returnVal = findGeneObservation(pJCas, beginOffset, endOffset);
    
    }
    
    
    return returnVal;
  } // end Method processTableRows() ---------------




// =================================================
  /**
   * findOneGeneName does a simple'sh lookup into the gene name
   * database - appending each query with " gene" to find
   * gene name matches. 
   * 
   * Within the offset bounds, traverse the sentences.
   * Each sentence has been bounded by \t and \n essentially
   * being a cell of a table, or a grammatical sentence within
   * those bounds.
   * 
   * The super.termLookupSimple will only lookup single words
   * The super.termLookupSimple will append " gene" to each query
   * The super.termLookupSimple will only create/return gene name
   * annotations that are not ambiguous. 
   * 
   * This method will return false if there was a problem with
   * the lookup - like finding two or more gene names in this block
   * or finding no gene name. 
   * 
   * @param pJCas
   * @param beginOffset
   * @param endOffset
   * @param boolean 
  */
  // =================================================
  private final boolean findOneGeneName(JCas pJCas, int beginOffset, int endOffset) {
    
    boolean returnVal = false;
    List<Annotation> sentences = UIMAUtil.getAnnotationsBySpan(pJCas, Sentence.typeIndexID, beginOffset, endOffset);
    List<Annotation> geneNames = new ArrayList<Annotation>();
    
    if ( sentences != null && !sentences.isEmpty() ) 
      
      for ( Annotation sentence : sentences ) {
        
       
        String sentenceText = sentence.getCoveredText();
        if ( sentenceText != null && sentenceText.trim().length() > 0 ) {
          Annotation geneName = super.termLookupSimple( pJCas, sentence, sentenceText) ;
          if ( geneName != null )
            geneNames.add(geneName);
        }
        
      } // end loop thru sentences of the block
    
      if ( geneNames.size() == 1 )
        returnVal = true;
        
     return returnVal;
  } // end Method findOneGeneName() -----------------


// =================================================
  /**
   * findGeneSlotsAndValues 
   * 
   * @param pJCas
   * @param pLineBuff
  */
  // =================================================
  private void findGeneSlotsAndValues(JCas pJCas, List<Annotation> pLineBuff) {
  
    findInLines(pJCas, "Gene:", TestName.class, pLineBuff);
    findInLines(pJCas, "DNA change:",GeneVariantObservation.class, pLineBuff);
    findInLines(pJCas, "Classification:", GeneVariantObservation.class, pLineBuff);
    findInLines(pJCas, "Amino Acid change:",GeneVariantObservation.class,  pLineBuff);
                        
    
  } // End Method findGeneSlotsAndValues() ---------


// =================================================
/**
 * find 
 * 
 * @param pJCas
 * @param pPattern
 * @param pAnnotationClass
 * @param pLineBuff
*/
// =================================================
private void findInLines(JCas pJCas, String pPattern, Class<?> pAnnotationClass, List<Annotation> pLineBuff) {
 
  if ( pLineBuff != null && !pLineBuff.isEmpty())
  for ( Annotation line : pLineBuff) 
    findInLine( pJCas, pPattern, pAnnotationClass, line );
  
  
} // end find() ------------------------------------


// =================================================
/**
 * findInLine pattern in this line
 * 
 * @param pJCas
 * @param pPattern
 * @param pAnnotationClass
 * @param pLine
*/
// =================================================
private void findInLine(JCas pJCas, String pPattern, Class<?> pAnnotationClass, Annotation pLine) {
  
  List<Annotation> sentences = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas,  Sentence.typeIndexID, pLine.getBegin(), pLine.getEnd(), false );
  
  if ( sentences != null && !sentences.isEmpty()) {
    UIMAUtil.sortByOffset(sentences);
    sentences = UIMAUtil.uniqueAnnotations(sentences);
    for ( int i = 0; i < sentences.size(); i++  )
      findInSentence( pJCas, pPattern, pAnnotationClass, sentences, i);
  }
  }


// =================================================
/**
 * findInSentence finds the pattern in this sentence
 * and creates an annotation from the next sentence
 * 
 * @param pJCas
 * @param pPattern
 * @param pAnnotationClass
 * @param pSentences
*/
// =================================================
private void findInSentence(JCas pJCas, String pPattern, Class<?> pAnnotationClass, List<Annotation> pSentences, int i) {
  
  Annotation sentence = pSentences.get(i);
  String txt = sentence.getCoveredText();
  
  int valueStart = -1;
  int valueEnd = -1;
  
  if ( txt != null && txt.trim().length() > 0 ) {
    
    if (  txt.contains( pPattern) ) {
        // assume the whole sentence after the found pattern is the value
        if ( i+1 < pSentences.size()) {
          valueStart = pSentences.get(i+1).getBegin();
          valueEnd   = pSentences.get(i+1).getEnd();
          createAnnotation( pJCas, pAnnotationClass, valueStart, valueEnd);
        }
      }
  }
} // end Method findInSentence() --------------------


// -----------------------------------------
/**
 * createAnnotation will create an annotation of the class pClassType.
 *
 * @param pJCas the j cas
 * @param pClassName the class name
 * @param pBeginOffset the begin offset
 * @param pEndOffset the end offset
 */
// -----------------------------------------
private void createAnnotation(JCas pJCas, Class<?> pClassName, int pBeginOffset, int pEndOffset) {

  try {
    Constructor<?> c = pClassName.getConstructor(new Class[] {
        JCas.class
    });
    Object statement = c.newInstance(pJCas);

    ((Concept) statement).setBegin(pBeginOffset);
    ((Concept) statement).setEnd(pEndOffset);
    ((Concept) statement).setId("GeneObservationsAnnotator_" + annotationCtr++);

    ((Concept) statement).addToIndexes(pJCas);

  } catch (Exception e) {
    e.printStackTrace();
    GLog.println( GLog.ERROR_LEVEL, this.getClass(), "createAnnotation", "Something went wrong here " + e.toString());
  }

} // end Method createAnnotation() ---



// =================================================
/**
 * findGeneObservation looks for the elements of a gene Observatoin
 *     gene name, 
 *     gene mutuation observation
 *     medication
 *     percent 
 *     
 * @param pJCas
 * @param pTableRow
 * @return List<Annotation>
*/
// =================================================
private final List<Annotation> findGeneObservation(JCas pJCas, int pBeginOffset, int pEndOffset) {
  
  List<Annotation> returnVal = null;
  Annotation anObservation = null;
  List<Annotation>      geneNames = UIMAUtil.getAnnotationsBySpan( pJCas, TestName.typeIndexID, pBeginOffset, pEndOffset, true);
  List<Annotation>interpretations = UIMAUtil.getAnnotationsBySpan( pJCas, GeneVariantObservation.typeIndexID, pBeginOffset, pEndOffset);
  List<Annotation>      therapies = UIMAUtil.getAnnotationsBySpan( pJCas, Medication.typeIndexID, pBeginOffset, pEndOffset);
  List<Annotation>         values = UIMAUtil.getAnnotationsBySpan( pJCas, TestValue.typeIndexID, pBeginOffset, pEndOffset);
  List<Annotation>        methods = UIMAUtil.getAnnotationsBySpan( pJCas, TestMethod.typeIndexID, pBeginOffset, pEndOffset);
  
  
  if ( geneNames != null && !geneNames.isEmpty()) {
   
    UIMAUtil.sortByOffset(geneNames);
    geneNames = UIMAUtil.uniqueAnnotations(geneNames);
    // ------------------------------------------------------
    // If there are no interpretations, therapies, values, and methods 
    //  this is not a gene Observation
    if ( interpretations == null  && therapies == null && values == null && methods == null)
      return null;
    
    
    // ------------------------------------------------------
    // if there are 2 or more genes in the same sentence, likely this is not an observation
    // remove the gene names 
    geneNames = unmarkMultipleGeneNamesInSentences(pJCas, geneNames);
    
    if ( geneNames == null || geneNames.isEmpty())
      return null;
    
    
    // -----------------------------------------------------
    // remove testNames that overlap gene names
    geneNames = removeOverlappingGeneNames( geneNames);
    
    
    // ------------------------------------------------------
    // Some interpretations include mention of the gene name
    // - unmark these as gene names
    geneNames = unmarkGeneNamesInInterpretations(geneNames, interpretations );
    
   
    
    if ( geneNames.size() == 1 ) {
      anObservation = createGeneObservation( pJCas, geneNames.get(0), interpretations, therapies, values, methods, pBeginOffset, pEndOffset);
      if ( anObservation != null) {
        if ( returnVal == null)  returnVal = new ArrayList<Annotation>();
        returnVal.add( anObservation);
      }
    }
    else 
      for ( int i = 0; i < geneNames.size(); i++ ) {
   
        Annotation geneName = null;
        Annotation interpretation = null;
        Annotation method = null;
        Annotation value = null;
      
        geneName = geneNames.get(i);
        if ( interpretations != null && interpretations.size() > i ) interpretation = interpretations.get(i);
        if ( methods         != null && methods.size()         > i )         method = methods.get(i);
        if ( values          != null && values.size()          > i )          value = values.get(i);
           anObservation = createGeneObservation( pJCas, geneName, interpretation, therapies, value, method,  pBeginOffset, pEndOffset);
        if ( anObservation != null) {
          if ( returnVal == null)  returnVal = new ArrayList<Annotation>();
          returnVal.add( anObservation);
        }
    }
  }
  
  return returnVal;
  
} // end Method findGeneObservation() --------------


// =================================================
/**
 * removeOverlappingGeneNames will remove test names
 * that overlap gene names.  We favor gene names
 * here because gene names have been looked up
 * in a terminology, where as testNames were found
 * by pattern.
 * 
 * @param geneNames
 * @return List<Annotation>
*/
// =================================================
  private final List<Annotation> removeOverlappingGeneNames(List<Annotation> geneNames) {
  
    List<Annotation> returnVal = new ArrayList<Annotation>( geneNames.size() );
    Annotation lastGene = null;
    
    UIMAUtil.sortByOffset(geneNames);
    if ( geneNames != null && geneNames.size() > 1) {
      for ( Annotation gene : geneNames ) {
        ((Concept)gene).setMarked(false);
        if ( lastGene != null && gene.getBegin() >= lastGene.getBegin() && gene.getEnd() <= lastGene.getEnd() ) {
          if ( lastGene.getClass().getName().endsWith("TestName"))
            ((Concept)lastGene).setMarked(true);
          else if ( gene.getClass().getName().endsWith("TestName"))
            ((Concept)gene).setMarked(true);
        }
        lastGene = gene;
      }
      for ( Annotation gene : geneNames )
        if ( !((Concept) gene).getMarked() ) {
          returnVal.add( gene);
          ((Concept)gene).setMarked(false);
        
        } else 
          gene.removeFromIndexes();
    } else {
      returnVal = geneNames;
    }
      
    
  return returnVal;
} // end Method removeOverlappingGeneNames() -------


// =================================================
/**
 * unmarkMultipleGeneNamesInSentences will remove
 * gene name mentions that are made in a single sentence.
 * 
 * @param pJCas
 * @param geneNames
 * @return List<Annotaton>  
*/
// =================================================
  private List<Annotation> unmarkMultipleGeneNamesInSentences(JCas pJCas, List<Annotation> geneNames) {
  
    List<Annotation> returnVal = null;
    
    for ( Annotation geneName: geneNames ) {
      List<Annotation> sentences = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas,  Sentence.typeIndexID,  geneName.getBegin(), geneName.getEnd() );
    
      if ( sentences != null && !sentences.isEmpty() ) {
        for ( Annotation sentence : sentences ) {
          List<Annotation> sentenceGenes = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas,  GeneName.typeIndexID,  sentence.getBegin(), sentence.getEnd() );
          if ( sentenceGenes != null && sentenceGenes.size() > 1)
            for ( Annotation sentenceGene : sentenceGenes)
              ((Concept) sentenceGene).setMarked( true);
        }
      }
    }
    for ( Annotation gene : geneNames )
      if ( !((Concept)gene).getMarked()) {
        if ( returnVal == null ) returnVal = new ArrayList<Annotation> (geneNames.size());
        returnVal.add( gene);
      } else {
        gene.removeFromIndexes();
      }
          
  return returnVal;
  } // end Method unmarkMultipleGeneNamesInSentences() -


// =================================================
/**
 * unmarkGeneNamesInInterpretations will delete gene names
 * that are within interpretations - 
 * 
 * @param pGeneNames
 * @param pInterpretations
 * @return List<Annotation>  the revised list of gene names
 * @deprecated
*/
// =================================================
  private final List<Annotation> unmarkGeneNamesInInterpretations(List<Annotation> pGeneNames, List<Annotation> pInterpretations) {
  
    List<Annotation>returnVal = new ArrayList<Annotation>( pGeneNames.size());
    for ( Annotation geneName: pGeneNames ) ((Concept) geneName).setMarked( false);
    
    if ( pInterpretations != null && !pInterpretations.isEmpty())
      for ( Annotation interpretation : pInterpretations ) 
        if ( pGeneNames != null && !pGeneNames.isEmpty() )
          for ( Annotation geneName: pGeneNames ) 
            if ( geneNameInInterpretation( interpretation, geneName)) 
              ((Concept) geneName).setMarked(true);
    
    for ( Annotation geneName : pGeneNames ) 
      if ( !((Concept) geneName).getMarked()) 
        returnVal.add( geneName);
      else 
        geneName.removeFromIndexes();
    
    return returnVal;
    
} // end Method unmarkGeneNamesInInterpretations() ----


// =================================================
/**
 * geneNameInInterpretation 
 * 
 * @param pInterpretation
 * @param pGeneName
 * @return boolean
*/
// =================================================
private final boolean geneNameInInterpretation(Annotation pInterpretation, Annotation pGeneName) {
  
  boolean returnVal = false;
  
  if ( pGeneName.getBegin() >= pInterpretation.getBegin() && 
       pGeneName.getBegin() < pInterpretation.getEnd()  &&
       pGeneName.getEnd()   <= pInterpretation.getEnd() )
    returnVal = true;
  
  return returnVal;
}


// =================================================
/**
 * createGeneObservation 
 * 
 * @param pJCas
 * @param pGeneName
 * @param pMutations
 * @param pMedications
 * @param pValues
 * @param pMethods
 * @param pBeginOffset
 * @param pEndOffset
 *
*/
// =================================================
private final Annotation createGeneObservation(JCas             pJCas,  
                                         Annotation       pGeneName,
                                         List<Annotation> pMutations, 
                                         List<Annotation> pMedications, 
                                         List<Annotation> pPercentages, 
                                         List<Annotation> pMethods,
                                         int              pBeginOffset,
                                         int              pEndOffset) {
 
  
  StringBuffer geneVarantObservationz = new StringBuffer();
  String       geneVarantObservations = null;
  StringBuffer therapies = new StringBuffer();
  StringBuffer percentages = new StringBuffer();
  
  if ( pMutations == null )  return null;
  
  
  for ( Annotation mutation : pMutations ) {
    String mu = mutation.getCoveredText();
    geneVarantObservationz.append( mutation.getCoveredText() + ";");
  }
  geneVarantObservations = geneVarantObservationz.toString();
  if ( geneVarantObservations != null && geneVarantObservations.endsWith(";"))
    geneVarantObservations = geneVarantObservations.substring(0, geneVarantObservations.length() -1);

  
  // -------------------------------------
  // Clean up geneVariantObservations
  geneVarantObservations = cleanGeneObservations( geneVarantObservations );
  
  
  StringBuffer geneNameInfo = new StringBuffer();
  if ( pGeneName == null )  return null;
  
  
  String otherInfo =  ((TestName) pGeneName).getOtherInfo() ;
  if ( otherInfo != null ) {
    String cols[] = U.split( otherInfo);
    String sourceId = cols[8];
    String sourceTerminology = cols[7];
    geneNameInfo.append( pGeneName.getCoveredText() + ":" + sourceId + ":" + sourceTerminology +  "|" );
  }
  
  
  if ( pMedications != null )
    for ( Annotation medication : pMedications ) {
      String motherInfo =  ((Medication)medication).getOtherInfo() ;
      if ( otherInfo != null ) {
        String cols[] = U.split( motherInfo);
        String sourceId = cols[8];
        String sourceTerminology = cols[7];
        therapies.append( medication.getCoveredText() + ":" + sourceId + ":" + sourceTerminology +  "|" );
      }
    }
      
  if ( pPercentages != null)
    for ( Annotation percentage : pPercentages)
      percentages.append( percentage.getCoveredText());
 
  String method = null;
  if ( pMethods != null ) {
    StringBuffer methodBuff = new StringBuffer();
    for ( Annotation method_: pMethods) {
      methodBuff.append( method_.getCoveredText() + ":");
    }
     method = methodBuff.toString();
    if ( method != null && method.endsWith(":"))
        method = method.substring(0, method.length() -1);
  }
  
  
  GeneObservation statement = new GeneObservation( pJCas);
  statement.setBegin( pBeginOffset );
  statement.setEnd( pEndOffset);
  statement.setId( "GeneObservationsAnnotator_" + this.annotationCtr++);
  
  
  
  statement.setTestName(  geneNameInfo.toString() );
  statement.setInterpretation( geneVarantObservations );
  statement.setTherapies(  therapies.toString());
  
  if ( percentages != null )
    statement.setTestValue(  percentages.toString() );
  
  statement.setMethod( method);
 

  statement.addToIndexes();
  
  return statement;
  
} // end Method createGeneObservation() ------------



// =================================================
/**
 * cleanGeneObservations cleans up the gene variant observations
 *   per comments in jira ciit 512
 * 
 *   Look for an "interpretation" value - 
 *   see complex regex and pattern replacement stuff. 
 *   This identifies a valid "variant" while discarding junk 
 *   (like replicated gene name, etc). IT works reliably across all files. 
 *   Also note the step for cleaning up the value by removing whitespace in certain cases
 * @param geneVarantObservations
 * @return
*/
// =================================================

private String cleanGeneObservations(String pGeneVarantObservations) {
  //Interpretation
  String returnVal = null;
  final String pattern =
      "([A-Z0-9]+ |Gene\\:\\s+|DNA change\\:\\s*|[Aa]mino [Aa]cid change\\:\\s*|)?" + "(.splice site.|[A-Z]\\d{2,5}[5A-Za-z\\*][A-Za-z\\d\\* ]|[Aa][Mm][Pp][Ll]."
     + "|AMP|^TMB.*|ND|[Dd]eleted"
     + "|.[Ee]xon.|[pc]\\s*\\.?\\s*\\dA-Z>{3,}|[Pp]romoter.*|Wild Type"
     + "|.[Ss]ubclonal.)(\\s++)?.*";
  
  if ( pGeneVarantObservations.matches(pattern)) 
    returnVal = pGeneVarantObservations.replaceAll(pattern, "$2").replaceAll("([A-Z0-9\\*\\-\\.>])\\s+([A-Z0-9\\*\\-\\.>])\\s*", "$1$2"); 

  return returnVal;
}


//=================================================
/**
* createGeneObservation 
* 
* @param pJCas
* @param pGeneName
* @param pInterpretation
* @param pTherapies
* @param pValue
* @param pMethod
* @param pBeginOffset
* @param pEndOffset
 * @return 
*/
//=================================================
private final Annotation createGeneObservation(JCas             pJCas,  
                                      Annotation       pGeneName,
                                      Annotation       pInterpretation,
                                      List<Annotation> pTherapies,
                                      Annotation       pValue, 
                                      Annotation       pMethod,
                                      int              pBeginOffset,
                                      int              pEndOffset) {

  
  
    
    GeneObservation statement = new GeneObservation( pJCas);
    statement.setBegin( pBeginOffset );
    statement.setEnd( pEndOffset);
    statement.setId( "GeneObservationsAnnotator_multipleGenes_" + this.annotationCtr++);

    if ( pGeneName       != null ) statement.setTestName(       pGeneName.getCoveredText());
    if ( pInterpretation != null ) statement.setInterpretation( pInterpretation.getCoveredText() );
    if ( pValue          != null ) statement.setTestValue(      pValue.getCoveredText());
    if ( pMethod         != null ) statement.setMethod   (      pMethod.getCoveredText());
    if ( pTherapies      != null ) {
      
        StringBuffer therapies = new StringBuffer();
        for ( Annotation medication : pTherapies ) {
          String otherInfo =  ((Medication)medication).getOtherInfo() ;
          if ( otherInfo != null ) {
            String cols[] = U.split( otherInfo);
            String sourceId = cols[8];
            String sourceTerminology = cols[7];
            therapies.append( medication.getCoveredText() + ":" + sourceId + ":" + sourceTerminology +  "|" );
          }
        }

      statement.setTherapies(      therapies.toString());
    }

    statement.addToIndexes();
    
    return statement;

} // end Method createGeneObservation() ------------





// =================================================
/**
 * processGeneTableRowSecondLine makes the first sentence
 * from this second line the geneObservation
 * 
 * @param pJCas
 * @param pSecondLine
*/
// =================================================
private final void processGeneTableRowSecondLine(JCas pJCas, Annotation pSecondLine) {
  
  List<Annotation> sentences = UIMAUtil.fuzzyFindAnnotationsBySpan(pJCas, Sentence.typeIndexID, pSecondLine.getBegin(), pSecondLine.getEnd());

  if ( sentences != null && !sentences.isEmpty() ){
    UIMAUtil.sortByOffset( sentences);
    sentences = UIMAUtil.uniqueAnnotations(sentences);
    
    // the sentence may have stuff from the pior line - ignore that
    int beginOffset = pSecondLine.getBegin();
    Annotation sentence = sentences.get(0);
    String buff = sentence.getCoveredText();
    int endOffset   = sentences.get(0).getEnd();
    
    if ( !coveredByOtherConcept( pJCas, beginOffset, endOffset ))
      createGeneVariantObservation( pJCas, beginOffset, endOffset );
  }
  
} // end Method processGeneTableRowSecondLine() ----




// =================================================
/**
 * coveredByOtherConcept returns true if this this
 * span haves a concept in it already
 * 
 * @param beginOffset
 * @param endOffset
 * @return boolean
*/
// =================================================
private final boolean coveredByOtherConcept(JCas pJCas, int beginOffset, int endOffset) {
  
  boolean returnVal = false;
  
  List<Annotation> concepts = UIMAUtil.getAnnotationsBySpan(pJCas,  Concept.typeIndexID,  beginOffset, endOffset, true);
  
  if ( concepts != null && !concepts.isEmpty()) 
    for (Annotation concept : concepts ) {
      String conceptName = concept.getClass().getName();
      if ( conceptName.endsWith("Method") || conceptName.endsWith("Medication")) {
        returnVal = true;
        break;
      }
    }
    
  return returnVal;
  
  
} // end Method notCoveredByOtherConcept() ---------


// =================================================
/**
 * createGeneVariantObservation 
 * 
 * @param pJCas
 * @param pBeginOffset
 * @param pEndOffset
*/
// =================================================
private GeneVariantObservation createGeneVariantObservation(JCas pJCas, int pBeginOffset, int pEndOffset ) {
  
  GeneVariantObservation statement = new GeneVariantObservation(pJCas );
  
  statement.setBegin( pBeginOffset);
  statement.setEnd(  pEndOffset );
  statement.setId( "GeneObservationAnnotator_" + this.annotationCtr++);
  statement.addToIndexes();
  
  
  return statement ;
} // end Method createGeneVAriantObservation() ------------







// =================================================
/**
 * markMedicationInGeneSectionAsHypothetical
 * Medication mentions in gene sections are recommendations - i.e. hypothetical - so these instances need to 
 * be marked as such - or taken out
 * 
 * [tbd]  I'm marking these as conditional because the concept doesn't have hypothetical as of yet.
 * 
 * @param pSection
*/
// =================================================
  private final void markMedicationInGeneSectionAsHypothetical(JCas pJCas, Annotation pSection) {
  
  
    List<Annotation> medications = UIMAUtil.getAnnotationsBySpan(pJCas, Medication.typeIndexID, pSection.getBegin(), pSection.getEnd() );
    
    if ( medications != null && !medications.isEmpty())
      for ( Annotation medication : medications)
        ((Medication)medication).setConditionalStatus( true);
    
    
} // end Method markMedicationInGeneSectionAsHypothetical() ----




//----------------------------------
/**
 * destroy
* 
 **/
// ----------------------------------
public void destroy() {
  this.performanceMeter.writeProfile( this.getClass().getSimpleName());
}


  //----------------------------------
  /**
   *  initialize    This is the standard uima way to pass parameters to an annotator.
   *                It is cumbersome.  It requires creating a config file with params
   *                in it, making it difficult to dynamically pass in parameters. 
   *                
   *                This method merges the uima way and keeping the ability to dynamically
   *                pass parameters into the class via - putting all parameters in a string
   *                array called "args" with each row containing a --key=value format.
   *                This way, arguments could be directly passed from command line,
   *                or read from a config file, or dynamically added to that string
   *                passed in. 
   *                
   *                It is important to adhere to the posix style "--" prefix and
   *                include a "=someValue" to fill in the value to the key. 
   * 
   * @param aContext
   * @throws ResourceInitializationException
   * 
   **/
  // ----------------------------------
  public void initialize(UimaContext aContext) throws ResourceInitializationException {
       
     
      String[] args = null;
      try {
        args                 = (String[]) aContext.getConfigParameterValue("args");  

        initialize(args);
        
      } catch (Exception e ) {
        String msg = "Issue in initializing class " + this.getClass().getName() + " " + e.toString() ;
        GLog.println(GLog.ERROR_LEVEL, msg);     // <------ use your own logging here
        throw new ResourceInitializationException();
      }
      
  
  } // end Method initialize() -------
  
  //----------------------------------
  /**
   * initialize initializes the class.  Parameters are passed in via a String
   *                array  with each row containing a --key=value format.
   *                
   *                It is important to adhere to the posix style "--" prefix and
   *                include a "=someValue" to fill in the value to the key. 
   * @param pArgs
   * @throws  ResourceInitializationException            
   * 
   **/
  // ----------------------------------
  public void initialize(String[] pArgs) throws ResourceInitializationException {
       
    
    
    // -----------------------
    // This method now calls geneNameLookupAnnotator - and that annotator
    // is no longer called from the pipeline directly, so it's got to be initizalized
    // here
    super.initialize(pArgs);
    
    this.performanceMeter = new ProfilePerformanceMeter( pArgs, this.getClass().getSimpleName() );
    
    this.proceduresParameter = U.getOption(pArgs,  "--termplateParam=", "aDefaultValue"); 
    
    try {
    // ------------------------
    // read in the section/type resource
    this.sectionInfo = new SectionMetaInfo( );
   
      
    } catch (Exception e) {
      e.printStackTrace();
      throw new ResourceInitializationException();
    }
  } // end Method initialize() -------
  
  
  // ---------------------------------------
  // Global Variables
  // ---------------------------------------
  protected int annotationCtr = 0;
  ProfilePerformanceMeter performanceMeter = null;
  private String  proceduresParameter = null;
  
} // end Class ProceduresAnnotator() ---------------

