// =================================================
/**
 * FromBioC creates uima cas's from files that are in the
 * bioC format
 *
 *
 * @author  Guy Divita 
 * @created March 12, 2014
 *
 * *  
 *   *
 *   * --- Copyright Notice: --------------------------------------------------
 *   *
 *   * Copyright 2014 United States Department of Veterans Affairs, 
 *   *                Health Services Research & Development Service
 *   *
 *   *  Licensed under the Apache License, Version 2.0 (the "License");
 *   *  you may not use this file except in compliance with the License.
 *   *  You may obtain a copy of the License at
 *   *
 *   *      http://www.apache.org/licenses/LICENSE-2.0
 *   *
 *   *  Unless required by applicable law or agreed to in writing, software
 *   *  distributed under the License is distributed on an "AS IS" BASIS,
 *   *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   *  See the License for the specific language governing permissions and
 *   *  limitations under the License. 
 *   * 
 *   * --- End Copyright Notice: ----------------------------------------------
 *   *
 * 

 */
// ================================================
package gov.va.vinci.nlp.framework.marshallers.bioC;


import gov.va.chir.model.DocumentHeader;
import gov.va.chir.model.VAnnotation;
import gov.va.vinci.nlp.framework.utils.U;
import gov.va.vinci.nlp.framework.utils.framework.uima.VUIMAUtil;
import gov.va.vinci.nlp.framework.utils.uima.UIMAUtil;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.uima.cas.CAS;
import org.apache.uima.collection.CollectionException;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.tcas.Annotation;
import org.apache.uima.resource.ResourceInitializationException;
import org.apache.uima.util.Progress;
import org.apache.uima.util.ProgressImpl;

import bioc.BioCAnnotation;
import bioc.BioCCollection;
import bioc.BioCDocument;
import bioc.BioCLocation;
import bioc.BioCPassage;
import bioc.io.BioCCollectionReader;
import bioc.io.BioCFactory;


public class FromBioC extends gov.va.vinci.nlp.framework.marshallers.reader.Reader {

	public static final String PARAM_INPUTDIR = "inputDirectory";

  private List<File> listOfFilesToProcess = null;

  // -----------------------------------------
  /** 
   * getNext retrieves the next document id from the list of document ids, queries the database fro 
   * annotations that share this document id, creates annotations for this id.
   * @param pCAS
   * @throws IOException
   * @throws CollectionException
   */
  // -----------------------------------------
  public void getNext(CAS pCAS, BioCDocument pDoc ) throws IOException, CollectionException {
  }
  
  // -----------------------------------------
	/** 
	 * getNext retrieves the next document id from the list of document ids, queries the database fro 
	 * annotations that share this document id, creates annotations for this id.
	 * @param pCAS
	 * @throws IOException
	 * @throws CollectionException
	 */
	// -----------------------------------------
	@Override
	public void getNext(CAS pCAS) throws IOException, CollectionException {
	 
	  JCas jcas = null;  
    try {
      jcas = pCAS.getJCas();
      
      File aFile = this.listOfFilesToProcess.get(this.fileCounter);
      
      BioCCollection collection = parseFile( aFile);
      
      List<BioCDocument> documents = collection.getDocuments();
      
      for ( BioCDocument doc : documents )
        getNext( jcas, doc );  // < ----------------- magic happens here
      
      
    } catch (IOException e ) {
      throw e;
    } catch ( CollectionException e2 ) {
      throw e2;
    } catch (Exception e3) {
      throw new CollectionException();
    }
    
      
	  
	}
	
  //-----------------------------------------
 /** 
  * getNext retrieves the next document id from the list of document ids, queries the database fro 
  * annotations that share this document id, creates annotations for this id.
  * @param pCAS
  * @throws IOException
  * @throws CollectionException
  */
 // -----------------------------------------
 public void getNext(JCas pJCas, BioCDocument pBioCDocument ) throws IOException, CollectionException {
  
   
	  
   
    try {
   
      
      File aFile = this.listOfFilesToProcess.get(this.fileCounter);
      
      BioCCollection collection = parseFile( aFile);
      
      List<BioCDocument> documents = collection.getDocuments();
      
    
      
      
      BioCDocument document = documents.get(0);
      String documentText   = getBioCTextFromDocumentPassages( document);
      String documentId     = document.getID();
      String documentURI    = aFile.getAbsolutePath();
      String documentTitle  = "unknown";
      String documentType   = "unknown";
      String documentName   = aFile.getName();
      int documentSpan      = documentText.length();
      String patientID      = "unknown";
      String referenceDate  = "unknown";
      String metaData       = null;
      
   
      pJCas.setDocumentText( documentText );
     
                
   
      // ----------------------------------
      // If there are any attributes at the document level pick them up here, and add it to the metaData
      Map<String, String> infons = document.getInfons();
      if ( infons != null && infons.size() > 0 ) {
        StringBuffer metaDataBuffer = new StringBuffer();
        Set<String> metaDataKeys = infons.keySet();
        for ( String metaDataKey : metaDataKeys) {
          String metaDataValue = infons.get(metaDataKey);
          metaDataBuffer.append( metaDataKey + ":" + metaDataValue + "|");
        }
        metaData = metaDataBuffer.toString();
      } // end if there is metaData
       
         VUIMAUtil.setDocumentHeader( jCas, documentId, documentName, documentType, documentTitle, documentMetaData, patientId, referenceDate, this.fileCounter);
      
      
        
      
      List<BioCPassage> passages = document.getPassages();

      if ( passages != null && passages.size() > 0 ) {
        convertAnnotations( pJCas, passages );
        
      } // end if there are any passages
    } catch (Exception e) {
      e.printStackTrace();
      String msg = "Issue getting the next cas " + e.toString();
      System.err.println(msg);
      throw new CollectionException();
    }
    
    } // =======================================================
  /**
   * getBioCTextFromDocumentPassages returns the aglomerated text
   * from all the passages
   * 
   * @param document
   * @return
   */
  // =======================================================
  private String getBioCTextFromDocumentPassages(BioCDocument pDocument) {
    
    String returnVal = null;
    List<BioCPassage> passages = pDocument.getPassages();
    
    if ( passages != null ) {
      StringBuffer buff = new StringBuffer();
      for ( BioCPassage passage : passages ) {
        
        buff.append(passage.getText() + '\n');
        
      }
      returnVal = buff.toString();
      
    }
    
    return returnVal;
    
  }  // End Method getBioCTextFromDocumentPassages() ======================
  

    // end Method getNext () ----------------------------
        
  // =======================================================
  /**
   * convertAnnotations transforms the annotations from passages 
   * to jas annotations
   * 
   * @param jcas
   * @param passages
   * @return
   */
  // =======================================================
  private List<Annotation> convertAnnotations(JCas jcas, List<BioCPassage> passages) {
  
    ArrayList<Annotation> uimaAnnotations = new ArrayList<Annotation>();
    
    for ( BioCPassage passage : passages ) {
      List<BioCAnnotation> boiCAnnotations = passage.getAnnotations();
      if ( boiCAnnotations != null && boiCAnnotations.size() > 0) {
        for ( BioCAnnotation annotation: boiCAnnotations ) {
          List<BioCLocation> locations = annotation.getLocations();
          BioCLocation location = locations.get(0);
          ArrayList<String >attributesPairs  = null;
          String annotationId = annotation.getID();
          
          int       beginOffset = location.getOffset();
          int              endOffset = beginOffset + location.getLength();
          Map<String, String> infons = annotation.getInfons();
          String  annotationType = "Annotation";
          
          if ( infons != null && infons.size() > 0 ) {
            Set<String> attributeKeys = infons.keySet();
            attributesPairs = new ArrayList<String>();
            for ( String attributeKey : attributeKeys) {
              String attributeValue = infons.get(attributeKey);
              
              if (attributeKey.equals("Type")) 
                annotationType = attributeValue;
              else  
                attributesPairs.add( attributeKey + "|" + attributeValue );
            } // end loop through the infons for this annotation
          } // end if there are any infons
          Annotation uimaAnnotation = createAnnotation ( jcas, annotationId, annotationType, beginOffset, endOffset, attributesPairs);
          uimaAnnotations.add( uimaAnnotation);
        } // end loop thru annotations
      }// end if there are any annotations
    } // end loop through passages
    
    return uimaAnnotations;
  }  // End Method convertAnnotations() ======================
  

    // =======================================================
  /**
   * createAnnotation 
   * 
   * @param pJcas
   * @param pAnnotationId
   * @param pAnnotationType
   * @param pBeginOffset
   * @param pEndOffset
   * @param pAttributeValuePairs
   */
  // =======================================================
  private org.apache.uima.jcas.tcas.Annotation createAnnotation(JCas pJCas, String pAnnotationId, String pAnnotationType, int pBeginOffset, int pEndOffset, ArrayList<String> pAttributeValuePairs) {
    
      org.apache.uima.jcas.tcas.Annotation returnValue = null;
      // ----------------------------------------------
      // Map this label to a uima class
      // ----------------------------------------------
     
      
      try {
      Class<?> uimaLabelClass = UIMAUtil.mapLabelToUIMAClass(pJCas, pAnnotationType);
      
         // Class<?> uimaLabelClass = UIMAUtil.mapLabelToUIMAClass(feature.getFeatureName());

      // ----------------------------------------------
      // create a UIMA annotation from this label
      // ----------------------------------------------
  
        Constructor<?> c = uimaLabelClass.getConstructor(new Class[] { JCas.class });
        Object uimaAnnotation = c.newInstance(pJCas);
        returnValue = (Annotation) uimaAnnotation;

        // --------------------------------------------------
        // Add span and slot attributes to the uimaAnnotation
        // --------------------------------------------------
        String className = "gov.va.vinci.nlp.framework.marshallers.bioC.FromBioC";
        try {
        VUIMAUtil.setProvenance(pJCas, (VAnnotation) uimaAnnotation, className);
        ((VAnnotation) uimaAnnotation).setBegin(pBeginOffset);
        ((VAnnotation) uimaAnnotation).setEnd(pEndOffset);
        ((VAnnotation) uimaAnnotation).setId( pAnnotationId);
        } catch (Exception e) {}
        ((Annotation) uimaAnnotation).setBegin(pBeginOffset);
        ((Annotation) uimaAnnotation).setEnd( pEndOffset);
       

        // ----------------------------------------------------
        // find the features (featureElements) associated with this annotation
        // (feature)
        // -----------------------------------------------------
       
        
        for ( String aFeature: pAttributeValuePairs ) {
          
          String [] cols = U.split( aFeature);
          String featureName = cols[0];
          String featureValue = cols[1];
          
         
              if (featureValue != null) {
                // --------------------------------------------------------------
                // Is there a generic way to find out if this feature is a class?
                // --------------------------------------------------------------
                Method uimaSetFeatureMethod = UIMAUtil.mapFeatureToUIMAFeature(uimaLabelClass, featureName);
                if (uimaSetFeatureMethod != null) {
                  try {
                    if (featureValue != null) {
                      Object[] methodArgs = null;
                      Class<?>[] parameterTypes = uimaSetFeatureMethod.getParameterTypes();
                      
                      if ( parameterTypes != null && parameterTypes.length > 0 && 
                                   parameterTypes[0].getName().indexOf("String") > 0 ) {
                         methodArgs = new Object[1];
                        methodArgs[0] = (Object) featureValue;
                      }
                
                      uimaSetFeatureMethod.invoke( uimaAnnotation, methodArgs);
                    }
                
                  } catch (Exception e) {}
                
              
            } // end loop through feature values
          

        } // end loop through the attributes/slots/features of this
          // annotation/classMention
        }
        
        } catch (Exception e) {
          e.printStackTrace();
          String msg = "Issue with creating a xx" + e.toString();
          System.err.println(msg);
          
        }
      
      return returnValue;
   
	}   // End Method createAnnotation() ======================


  // -----------------------------------------
	/** 
	 * getProgress is method required for the 
	 * interface that is populated with the 
	 * fraction of files processed by the number of files to process.
	 *
	 * @return Progress[]
	 */
	// -----------------------------------------
	@Override
	public Progress[] getProgress() {
		Progress[] p = new Progress[] { new ProgressImpl(this.fileCounter, this.numberOfFiles, Progress.ENTITIES)};
		return p;

	} // end Method getProgress() --------------




  // -----------------------------------------
  /** 
   * hasNext
   *
   * @return
   * @throws IOException
   * @throws CollectionException  <---- why not anymore?
   */
  // -----------------------------------------
  public boolean hasNext()  {
    boolean returnValue = false;
    

    if (this.fileCounter < this.numberOfFiles ) 
      returnValue = true;
    
     return returnValue;
  } // end Method hasNext() -----------------
	
	
	
//-----------------------------------------
 /** 
  * initialize reads the directory containing the input files.  By default, this
  * recurses through sub directories.
  * 
  * @param pInputDir
  * @throws ResourceInitializationException

  */
 // -----------------------------------------
 public void initialize(String pInputDir ) throws ResourceInitializationException  {
   
   initialize( pInputDir, true);
   
 } // End Method initialize() ---------------------------
 
 
  // -----------------------------------------
    /** 
     * initialize opens the directory containing .txt files and files 
     * that do not have an extension 
     * 
     *
     * @param pInputFile
     * @param recurseIntoSubDirs
     * @throws IOException
     * @throws CollectionException
     */
    // -----------------------------------------
    public void initialize(String pInputDir, boolean recurseIntoSubDirs ) throws ResourceInitializationException  {
      
      
      File inputDir = null;
      this.listOfFilesToProcess = new ArrayList<File>();
      
      if ( pInputDir != null && pInputDir.length() > 0 ) {
        
        inputDir = new File ( pInputDir);
        
        if ( inputDir.isDirectory() && inputDir.canRead() ) {
          
          File[] filesAndSubDirs = inputDir.listFiles();
            
          if ( recurseIntoSubDirs ) {
             getFiles(this.listOfFilesToProcess, filesAndSubDirs );
          } else {
            this.listOfFilesToProcess = filterFiles( filesAndSubDirs) ;
          }
        } // end if the inputDir can be read                
      } // end if the inputDir is not null
      
  
      
      this.numberOfFiles = this.listOfFilesToProcess.size();
      System.err.println("The number ofiles to process = " + this.numberOfFiles);
      
    
           
  } // end Method initialize() --------------
    
    
    /* (non-Javadoc)
     * @see org.apache.uima.collection.base_cpm.BaseCollectionReader#close()
     */
    @Override
    public void close() throws IOException {
     
    }  // End Method close() ======================
    
    
    
  // ------------------------------------------
    /**
     * createDocumentHeaderAnnotation
     *
     *
     * @param pJCas
     * @param pDocumentId
     * @param pDocumentTitle
     * @param pDocumentType
     * @param pDocumentName
     * @param pDocumentSpan
     * @param pPatientId
     * @param pReferenceDate,
     * @param pDocumentMetaData
     */
    // ------------------------------------------
    private void createDocumentHeaderAnnotation(JCas   pJCas, 
                                                String pDocumentId, 
                                                String pDocumentTitle, 
                                                String pDocumentType,
                                                String pDocumentName,
                                                int    pDocumentSpan,
                                                String pPatientId,
                                                String pReferenceDate,
                                                String pDocumentMetaData) {
      
      DocumentHeader documentHeader = new DocumentHeader(pJCas);
      
      documentHeader.setDocumentId( pDocumentId);
      documentHeader.setDocumentName( pDocumentName);
      documentHeader.setBegin( 0 );
      documentHeader.setEnd( pDocumentSpan);
      documentHeader.setDocumentType( pDocumentType);
      documentHeader.setDocumentTitle( pDocumentTitle);
      documentHeader.setOtherMetaData( pDocumentMetaData);
      documentHeader.setPatientID( pPatientId);
      documentHeader.setReferenceDate(pReferenceDate);    
      documentHeader.addToIndexes(pJCas);
      
      
    }  // End Method createDocumentHeaderAnnotation() -----------------------


  // =======================================================
    /**
     * filterFiles returns a list of text files
     * 
     * @param pFiles
     * @return List<File>
     */
    // =======================================================
    private List<File> filterFiles(File[] pFiles) {
    
      ArrayList<File> filteredFiles = new ArrayList<File>(pFiles.length);
      for ( File file: pFiles )
        if ( filterInBioCFiles( file))
          filteredFiles.add( file);
        
      return filteredFiles;
    }  // End Method filterFiles() ======================
    


    // =======================================================
    /**
     * getFiles retrieves the list of files from the directory
     * that match the filtering criteria
     * 
     * @param pListOfFiles
     * @param pFilesAndSubDirs
     * 
     */
    // =======================================================
    private void  getFiles(List<File> pListOfFiles, File[] pFilesAndSubDirs) {
      
      for ( File file: pFilesAndSubDirs )
        if ( file.isDirectory()) {
          getFiles( pListOfFiles, file.listFiles());
        } else if ( filterInBioCFiles ( file )){
         // System.err.println("adding file " + file.getAbsolutePath());
          pListOfFiles.add( file);
        }
      
    }   // End Method getFiles() ======================
    


    // =======================================================
    /**
     * filterInBioCFiles returns true if the file is a .bioC.xml file
     * 
     * @param pFile
     * @return boolean
     */
    // =======================================================
    private boolean filterInBioCFiles(File pFile) {
     
      boolean returnValue = false;
      String extension = U.getFileExtension(pFile.getName());
      
      if ( extension == null ||
           extension.indexOf("xml") > 0  &&
           extension.indexOf("bioC") > 0 ) {
          
        returnValue = true;
      }
     
      return returnValue;
      
    }  // End Method filterInTextFiles() ======================
    
    
	// =======================================================
    /**
     * parseFile opens the file, reads in the collection. There 
     * is an assumption that there is a a one-to-one correspondence 
     * between collection and one cas. 
     * 
     * The toBioC, will put just one document in the collection.
     * 
     * @param pInputFile
     * @return AnnotationRecord[]
     * @throws Exception 
     */
    // =======================================================
    private BioCCollection parseFile(File pInputFile) throws Exception {
      
      BioCFactory factory = BioCFactory.newFactory(BioCFactory.WOODSTOX);
      BioCCollectionReader reader = factory.createBioCCollectionReader(new FileReader(pInputFile));
        
      BioCCollection collection = reader.readCollection();

      collection.getDocuments();
      
      reader.close();
       
      return collection ;
      // End Method parseFile() ======================
    }

 

  // ----------------------------------------
	// Class Variables
	// ----------------------------------------
	
	private int                        fileCounter = 0;
	private int                      numberOfFiles = 0;
	private BioCDocument[]                 records = null;
  

	
} // end Class MultiAnnotationRecordCollectionReader() ----

