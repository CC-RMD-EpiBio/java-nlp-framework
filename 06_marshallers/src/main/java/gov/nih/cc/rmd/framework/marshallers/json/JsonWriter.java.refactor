/*
 * Copyright 2018 Ciitizen Corp. - All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains the property of Ciitizen Corp.
 * The intellectual and technical concepts contained herein are proprietary to
 * Ciitizen Corp. and may be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.  Dissemination of this information
 * or reproduction of this material is strictly forbidden.
 */
/**
 * JsonWriter writes out annotations into json objects
 *
 * @author  Guy Divita 
 * @created Feb 18, 2018
 *
 * 
 */
// ================================================
package com.ciitizen.framework.marshallers.json;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.uima.UimaContext;
import org.apache.uima.analysis_engine.AnalysisEngineProcessException;
import org.apache.uima.cas.CASException;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.cas.FSArray;
import org.apache.uima.jcas.cas.StringArray;
import org.apache.uima.jcas.tcas.Annotation;
import org.apache.uima.resource.ResourceInitializationException;

import com.ciitizen.Medication;
import gov.nih.cc.rmd.nlp.framework.GeneObservation;
import gov.nih.cc.rmd.nlp.framework.Observation;
import gov.nih.cc.rmd.nlp.framework.ObservationsPanel;
import gov.nih.cc.rmd.nlp.framework.SectionZone;
import gov.nih.cc.rmd.nlp.framework.containers.json.AssertionProperties;
import gov.nih.cc.rmd.nlp.framework.containers.json.CodedEntry;
import gov.nih.cc.rmd.nlp.framework.containers.json.JsonAnnotation;
import gov.nih.cc.rmd.nlp.framework.containers.json.JsonDocumentAnnotations;
import gov.nih.cc.rmd.nlp.framework.containers.json.Offsets;
import gov.nih.cc.rmd.nlp.framework.containers.json.Snippet;
import com.ciitizen.handlers.impl.DefaultDataTypeMatcher;

import gov.va.chir.model.ClinicalStatement;
import gov.va.chir.model.DocumentHeader;
import gov.va.chir.model.LexicalElement;
import gov.va.chir.model.VAnnotation;
import gov.va.vinci.model.Concept;
//import gov.nih.cc.rmd.nlp.framework.VitalsObservation;
import gov.nih.cc.rmd.nlp.framework.marshallers.html.HTMLWriter;
import gov.nih.cc.rmd.nlp.framework.utils.GLog;
import gov.nih.cc.rmd.nlp.framework.utils.ProfilePerformanceMeter;
import gov.nih.cc.rmd.nlp.framework.utils.U;
import gov.nih.cc.rmd.nlp.framework.utils.framework.uima.VUIMAUtil;
import gov.nih.cc.rmd.nlp.framework.utils.uima.UIMAUtil;

/**
 * JSON Writer.
 */
public class JsonWriter extends gov.nih.cc.rmd.nlp.framework.marshallers.writer.AbstractWriter {

  /** The data matcher. */
  private DefaultDataTypeMatcher dataMatcher;

  // =======================================================
  /**
   * Constructor JsonWriter creates a json writer. This is the default
   * constructor.
   * 
   * The writer needs to know where to put the output files By default, it's
   * --outputDir=./json
   * 
   *
   * @throws ResourceInitializationException the resource initialization
   *           exception
   */
  // =======================================================
  public JsonWriter() throws ResourceInitializationException {

    String args[] = new String[1];
    args[0] = "--outputDir=./json";
    this.initialize(args);

  } // end Constructor() ---------------------

  // =======================================================
  /**
   * Constructor JsonWriter creates a json writer.
   * 
   *
   * @param pArgs the args
   * @throws ResourceInitializationException the resource initialization
   *           exception
   */
  // =======================================================
  public JsonWriter(String[] pArgs) throws ResourceInitializationException {

    this.initialize(pArgs);

  } // end Constructor() ---------------------

  // -----------------------------------------
  /**
   * 
   * process iterates through all annotations, filters out those that should be
   * filtered out, then pushes them into a database store.
   * 
   * Each document should include a DocumentAnnotation annotation and a
   * documentHeader annotation for re-animation purposes.
   *
   * @param pJCas the j cas
   * @throws AnalysisEngineProcessException the analysis engine process
   *           exception
   */
  // -----------------------------------------
  @Override
  public void process(JCas pJCas) throws AnalysisEngineProcessException {

    try {
      this.performanceMeter.startCounter();
      JsonDocumentAnnotations currentJsonDoc = processAPI(pJCas);

      // --------------------------------
      // Write this out to an output file
      // --------------------------------
      write(pJCas, currentJsonDoc);

      this.performanceMeter.stopCounter();
    } catch (Exception e) {
      e.printStackTrace();
      GLog.println(GLog.ERROR_LEVEL, "Issue processing to json the annotations " + e.toString());
    }

  } // end Method process() ------------------

  // =================================================
  /**
   * write writes the json file out to a file. The name of the file is taken
   * from the documentHeader's document name or generated. The files are printed
   * out to the --outputDir=xxx + "./json/"
   *
   * @param pJCas the j cas
   * @param pCurrentJsonDoc the current json doc
   * @throws Exception the exception
   */
  // =================================================
  private final void write(JCas pJCas, JsonDocumentAnnotations pCurrentJsonDoc) throws Exception {
  
    String filename = null;
    try {
      filename = renderFileName(pJCas, this.outputDir);
      PrintWriter out = new PrintWriter(filename);
     
      out.print(pCurrentJsonDoc.toString());
      out.close();

    } catch (Exception e) {
      e.printStackTrace();
      GLog.println(GLog.ERROR_LEVEL, "Issue writing file " + filename + " " + e.toString());
      throw e;
    }
  } // end Method write() --------------------

  // -----------------------------------------
  /**
   * 
   * processAPI iterates through all annotations, filters out those that should
   * be filtered out, then pushes them into a database store.
   * 
   * Each document should include a DocumentAnnotation annotation and a
   * documentHeader annotation for re-animation purposes.
   *
   * @param pJCas the j cas
   * @return the json document annotations
   * @throws AnalysisEngineProcessException the analysis engine process
   *           exception
   */
  // -----------------------------------------
  public final JsonDocumentAnnotations processAPI(JCas pJCas)
    throws AnalysisEngineProcessException {

    // ------------------------
    // get document meta data
    DocumentHeader documentHeader = VUIMAUtil.getDocumentHeader(pJCas);

    // ------------------------
    // Create a JsonDocument
    JsonDocumentAnnotations jDoc = new JsonDocumentAnnotations();

    setMetaData(jDoc, documentHeader);

    // ----------------------
    // set the text
    jDoc.setDocumentContent(pJCas.getDocumentText());

    // ----------------------
    // set the annotations
    List<JsonAnnotation> annotations = getJSonAnnotations(pJCas, this.numberOfContextLines);
    jDoc.setAnnotations(annotations);

    // ----------------------
    // Set the html here
    String annotationsHTML = getHTMLDoc(pJCas);
    jDoc.setAnnotationsHtml(annotationsHTML);

    // ----------------------
    // Set the annotation VTT docs here
    // String[][] vttDocs = getVTTDocs( pJCas);

    return jDoc;

  } // end Method processAPI() -----------------------

  // =================================================
  /**
   * getAnnotationsHTMLDoc returns the string to render the annotations in html
   * format
   * 
   * This method has the side effect of altering the section zones so that they
   * do not overlap with the content headings. The uima annotations are altered.
   * Downstream annotations from the cas will have the altered section zones.
   *
   * @param pJCas the j cas
   * @return String
   */
  // =================================================
  private final String getHTMLDoc(JCas pJCas) {
    String returnVal = null;

    try {

      this.sectionViewAnnotator.process(pJCas);

      returnVal = this.htmlWriter.processApi(pJCas);
    } catch (Exception e) {
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "getHTMLDoc",
          "Issue trying to render into html : " + e);
    }
    return returnVal;
  } // end Method getAnnotationsHTMLDoc() -------------

  // =================================================
  /**
   * getJSonAnnotations creates annotations for each UIMA annotation
   * 
   * This method assumes that all annotations have been filtered to the only
   * annotations you want to see from this point forward. If you don't want to
   * see documentHeader, or document annotations, filter them out before this
   * gets called.
   *
   * @param pJCas the j cas
   * @param pNumberOfContextLines the number of context lines
   * @return List<JsonAnnotation>
   */
  // =================================================
  private final List<JsonAnnotation> getJSonAnnotations(JCas pJCas, int pNumberOfContextLines) {

    ArrayList<JsonAnnotation> jsonAnnotations = null;
    List<Annotation> allAnnotations = UIMAUtil.getAnnotations(pJCas);
    String referenceDate = VUIMAUtil.getReferenceDate(pJCas);

    if (allAnnotations != null && !allAnnotations.isEmpty()) {
      jsonAnnotations = new ArrayList<JsonAnnotation>();
      for (Annotation uimaAnnotation : allAnnotations) {
        JsonAnnotation jsonAnnotation =
            createJsonAnnotation(pJCas, pNumberOfContextLines, uimaAnnotation, referenceDate);
        if (jsonAnnotation != null)
          jsonAnnotations.add(jsonAnnotation);
      }
    }

    return jsonAnnotations;
  } // end Method getJsonAnnotations() ---------------

  // =================================================
  /**
   * createJsonAnnotation transforms a uima annotation into a json annotation
   * 
   * Implementation note here: get the uima specific stuff here, before creating
   * the json objects - we don't want uima specific stuff creeping into the
   * containers.
   *
   * @param pJCas the j cas
   * @param pNumberOfContextLines the number of context lines
   * @param pUimaAnnotation the uima annotation
   * @param pReferenceDate the reference date
   * @return JsonAnnotation
   */
  // =================================================
  private final JsonAnnotation createJsonAnnotation(JCas pJCas, int pNumberOfContextLines,
    Annotation pUimaAnnotation, String pReferenceDate) {

    JsonAnnotation returnVal = null;
    try {

      Offsets offsets = getOffsets(pUimaAnnotation);
      String label = getAnnotationLabel(pUimaAnnotation);
      String provenance = getProvenance(pUimaAnnotation);
      String id = getId(pUimaAnnotation);
      String section = getSection(pJCas, pUimaAnnotation);

      String documentText = pUimaAnnotation.getView().getDocumentText();
      try {
        String coveredText = pUimaAnnotation.getCoveredText();
        if (coveredText == null || coveredText.trim().length() == 0)
          return null;
      } catch (Exception e) {
        return null;
      }
      if (offsets.getBeginOffset() < 0 || offsets.getEndOffset() > documentText.length()) {
        GLog.println(GLog.ERROR_LEVEL, this.getClass(), "getJSonAnnotations",
            "Invalid annotation offsets: " + offsets + " for document of length "
                + documentText.length() + ", annotation id: " + id + ", skipping...");
        return null;
      }
      String coveredText = pUimaAnnotation.getCoveredText();
      String eventDate = getEventDate(pJCas, pUimaAnnotation, pReferenceDate);

      // structural annotations
      if (label.endsWith("Line"))
        returnVal = new com.ciitizen.framework.containers.json.Line(label, id, coveredText,
            provenance, offsets);
      if (label.endsWith("Number"))
        returnVal = new com.ciitizen.framework.containers.json.JsonAnnotation(label, id,
            coveredText, provenance, offsets);
      else if (label.endsWith("NumberRange"))
        returnVal = new com.ciitizen.framework.containers.json.JsonAnnotation(label, id,
            coveredText, provenance, offsets);
      else if (label.endsWith("UnitOfMeasure"))
        returnVal = new com.ciitizen.framework.containers.json.JsonAnnotation(label, id,
            coveredText, provenance, offsets);
      else if (label.endsWith("PhoneNumber"))
        returnVal = new com.ciitizen.framework.containers.json.JsonAnnotation(label, id,
            coveredText, provenance, offsets);
      else if (label.endsWith("URL"))
        returnVal = new com.ciitizen.framework.containers.json.JsonAnnotation(label, id,
            coveredText, provenance, offsets);
      else if (label.endsWith("Person"))
        returnVal = new com.ciitizen.framework.containers.json.JsonAnnotation(label, id,
            coveredText, provenance, offsets);
      else if (label.endsWith("Email"))
        returnVal = new com.ciitizen.framework.containers.json.JsonAnnotation(label, id,
            coveredText, provenance, offsets);
      else if (label.endsWith("Zipcode"))
        returnVal = new com.ciitizen.framework.containers.json.JsonAnnotation(label, id,
            coveredText, provenance, offsets);

      else if (label.endsWith("CollectionDate")) {
        returnVal = new com.ciitizen.framework.containers.json.JsonAnnotation(label, id,
            coveredText, provenance, offsets);
      }

      else if (label.endsWith("DocumentHeader"))
        returnVal = new com.ciitizen.framework.containers.json.DocumentHeader(label, id, provenance,
            pReferenceDate, eventDate);
      // else if (label.endsWith( "Section")) returnVal = new
      // com.ciitizen.framework.containers.json.Section(label, id, coveredText,
      // provenance, offsets, section );
      else if (label.endsWith("SectionZone")) {
        section = getSection(pJCas, pUimaAnnotation);
        returnVal = new com.ciitizen.framework.containers.json.Section(label, id, coveredText,
            provenance, offsets, section);
      }

      else if (label.endsWith("PageHeader"))
        returnVal = new com.ciitizen.framework.containers.json.Section(label, id, coveredText,
            provenance, offsets, "pageHeader");
      else if (label.endsWith("PageFooter"))
        returnVal = new com.ciitizen.framework.containers.json.Section(label, id, coveredText,
            provenance, offsets, "pageFooter");

      else {

        if (label.endsWith("Phrase"))
          returnVal = new com.ciitizen.framework.containers.json.Phrase(label, id, coveredText,
              provenance, section, offsets);
        else if (label.endsWith("Sentence"))
          returnVal = new com.ciitizen.framework.containers.json.Sentence(label, id, coveredText,
              provenance, section, offsets);
        else if (label.endsWith("SlotValue"))
          returnVal = new com.ciitizen.framework.containers.json.SlotValue(label, id, coveredText,
              provenance, section, offsets);
        else if (label.endsWith("TemplateLabel1"))
          returnVal = new com.ciitizen.framework.containers.json.TemplateLabel1(label, id,
              coveredText, section, offsets);

        else {

          AssertionProperties assertionProperties = getAssertionProperties(pJCas, pUimaAnnotation);

          if (label.endsWith("Word"))
            returnVal = new com.ciitizen.framework.containers.json.Word(label, id, coveredText,
                provenance, section, offsets, assertionProperties);
          else if (label.endsWith("Date"))
            returnVal = new com.ciitizen.framework.containers.json.Date(label, id, coveredText,
                provenance, section, offsets, assertionProperties);
          else if (label.endsWith("ReferenceDate"))
            returnVal = new com.ciitizen.framework.containers.json.Date(label, id, coveredText,
                provenance, section, offsets, assertionProperties);
          else {
            if (label.endsWith("ClinicalStatement"))
              returnVal = createClinicalStatement(pJCas, pUimaAnnotation, label, id, coveredText,
                  provenance, section, offsets, assertionProperties, pReferenceDate, eventDate);
            else {
              String parentAnnotationId = getParentAnnotationId(pUimaAnnotation); // <---
                                                                                  // this
                                                                                  // requires
                                                                                  // some
                                                                                  // thought

              if (label.endsWith("LexcialElement"))
                returnVal = createJsonTerm(pUimaAnnotation, label, id, coveredText, provenance,
                    section, offsets, assertionProperties, parentAnnotationId);
              else if (label.endsWith("CodedEntry"))
                returnVal = createCodedEntry(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId);
              else if (label.endsWith("Concept"))
                returnVal = createConcept(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId, pReferenceDate,
                    eventDate);
              else if (label.endsWith("Problem"))
                returnVal = createConcept(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId, pReferenceDate,
                    eventDate);
              else if (label.endsWith("Medication"))
                returnVal = createMedicationConcept(pUimaAnnotation, label, id, coveredText,
                    provenance, assertionProperties, section, offsets, parentAnnotationId,
                    pReferenceDate, eventDate);

              else if (label.endsWith("VitalsObservationsPanel"))
                returnVal = createObservationsPanel(pUimaAnnotation, label, id, coveredText,
                    provenance, assertionProperties, section, offsets, parentAnnotationId,
                    pReferenceDate, eventDate);
              else if (label.endsWith("GeneObservationsPanel"))
                returnVal = createObservationsPanel(pUimaAnnotation, label, id, coveredText,
                    provenance, assertionProperties, section, offsets, parentAnnotationId,
                    pReferenceDate, eventDate);
              else if (label.endsWith("LabObservationsPanel"))
                returnVal = createObservationsPanel(pUimaAnnotation, label, id, coveredText,
                    provenance, assertionProperties, section, offsets, parentAnnotationId,
                    pReferenceDate, eventDate);
              else if (label.endsWith("ObservationsPanel"))
                returnVal = createObservationsPanel(pUimaAnnotation, label, id, coveredText,
                    provenance, assertionProperties, section, offsets, parentAnnotationId,
                    pReferenceDate, eventDate);

              else if (label.endsWith("GeneObservation"))
                returnVal = createGeneObservationConcept(pUimaAnnotation, label, id, coveredText,
                    provenance, assertionProperties, section, offsets, parentAnnotationId,
                    pReferenceDate, eventDate);
              else if (label.endsWith("LabObservation"))
                returnVal = createObservationConcept(pUimaAnnotation, label, id, coveredText,
                    provenance, assertionProperties, section, offsets, parentAnnotationId,
                    pReferenceDate, eventDate);
              else if (label.endsWith("VitalsObservation"))
                returnVal = createVitalsObservationConcept(pUimaAnnotation, label, id, coveredText,
                    provenance, assertionProperties, section, offsets, parentAnnotationId,
                    pReferenceDate, eventDate);

              else if (label.endsWith("GeneVariantObservation"))
                 ; // don't make a json object of this  // <---- leave this in so that geneVariantObservations don't
                                                        //       get caught on the next catch all looking
                                                        //       for generic Observations
                                                        //       GD 2018/09/12
              else if (label.endsWith("Observation"))
                returnVal = createObservationConcept(pUimaAnnotation, label, id, coveredText,
                    provenance, assertionProperties, section, offsets, parentAnnotationId,
                    pReferenceDate, eventDate);

              else if (label.endsWith("Symptom"))
                returnVal = createConcept(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId, pReferenceDate,
                    eventDate);
              else if (label.endsWith("Diagnosis"))
                returnVal = createConcept(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId, pReferenceDate,
                    eventDate);
              else if (label.endsWith("CancerStage"))
                returnVal = createConcept(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId, pReferenceDate,
                    eventDate);
              else if (label.endsWith("Condition"))
                returnVal = createConcept(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId, pReferenceDate,
                    eventDate);
              else if (label.endsWith("Procedure"))
                returnVal = createConcept(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId, pReferenceDate,
                    eventDate);
              else if (label.endsWith("CancerDiagnosis"))
                returnVal = createConcept(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId, pReferenceDate,
                    eventDate);
              else if (label.endsWith("SpecimenSite"))
                returnVal = createConcept(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId, pReferenceDate,
                    eventDate);

              else if (label.endsWith("Person"))
                returnVal = createConcept(pUimaAnnotation, label, id, coveredText, provenance,
                    assertionProperties, section, offsets, parentAnnotationId, pReferenceDate,
                    eventDate);

            }
          }
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "createJsonAnnotation",
          "Issue creating the json " + e.toString());
    }

    return returnVal;
  } // End Method createJsonAnnotation() ---------------

  // =================================================
  /**
   * getEventDate [TBD] the eventDate annotator has to start creating events and
   * the logic of passing event dates set here.
   *
   * @param pJCas the j cas
   * @param pUimaAnnotation the uima annotation
   * @param pReferenceDate the reference date
   * @return the event date
   */
  // =================================================
  private String getEventDate(JCas pJCas, Annotation pUimaAnnotation, String pReferenceDate) {

    String eventDate = VUIMAUtil.getEventDate(pUimaAnnotation, pReferenceDate);
    return eventDate;
  }

  // =================================================
  /**
   * createConcept .
   *
   * @param pUimaAnnotation the uima annotation
   * @param pLabel the label
   * @param pId the id
   * @param pCoveredText the covered text
   * @param pProvenance the provenance
   * @param pAssertionProperties the assertion properties
   * @param pSection the section
   * @param pOffsets the offsets
   * @param parentAnnotationId the parent annotation id
   * @param pReferenceDate the reference date
   * @param pEventDate the event date
   * @return JsonAnnotation
   */
  // =================================================
  private JsonAnnotation createConcept(Annotation pUimaAnnotation, String pLabel, String pId,
    String pCoveredText, String pProvenance, AssertionProperties pAssertionProperties,
    String pSection, Offsets pOffsets, String parentAnnotationId, String pReferenceDate,
    String pEventDate) {

    JsonAnnotation returnVal = null;
    String pConceptName = ((Concept) pUimaAnnotation).getConceptNames();
    String pConceptId = ((Concept) pUimaAnnotation).getCuis();
    String pSemanticTypes = ((Concept) pUimaAnnotation).getCategories();
    String referenceDate = ((Concept) pUimaAnnotation).getReferenceDate();
    String eventDate = ((Concept) pUimaAnnotation).getEventDate();
    String statementDate = ((Concept) pUimaAnnotation).getStatementDate();
    String otherInfo = ((Concept) pUimaAnnotation).getOtherInfo();

    String sourceId = "";
    String sourceTerminology = "";
    if (otherInfo != null) {
      String[] otherInfoCols = U.split(otherInfo);
      if (otherInfoCols != null && otherInfoCols.length > 8) {

        sourceTerminology = otherInfoCols[7];
        sourceId = otherInfoCols[8];
      }
    } else {
      // shapes are concepts - they don't have otherInfo
    }

    returnVal =
        new com.ciitizen.framework.containers.json.Concept(pLabel, pId, pCoveredText, pProvenance,
            pAssertionProperties, pSection, pOffsets, parentAnnotationId, pConceptName, pConceptId,
            pSemanticTypes, referenceDate, statementDate, eventDate, sourceId, sourceTerminology);

    return returnVal;
  } // end Method createConcept() --------------------

  // =================================================
  /**
   * createMedicationConcept includes the clinical status, start date, stopped
   * date, prescribedDate, filledDate, doseForm, strength, indication [tbd],
   * instructions[tbd], brandName[tbd], .
   *
   * @param pUimaAnnotation the uima annotation
   * @param pLabel the label
   * @param pId the id
   * @param pCoveredText the covered text
   * @param pProvenance the provenance
   * @param pAssertionProperties the assertion properties
   * @param pSection the section
   * @param pOffsets the offsets
   * @param parentAnnotationId the parent annotation id
   * @param pReferenceDate the reference date
   * @param pEventDate the event date
   * @return JsonAnnotation
   */
  // =================================================
  private JsonAnnotation createMedicationConcept(Annotation pUimaAnnotation, String pLabel,
    String pId, String pCoveredText, String pProvenance, AssertionProperties pAssertionProperties,
    String pSection, Offsets pOffsets, String parentAnnotationId, String pReferenceDate,
    String pEventDate) {

    JsonAnnotation returnVal = null;
    String pConceptName = ((Concept) pUimaAnnotation).getConceptNames();
    String pConceptId = ((Concept) pUimaAnnotation).getCuis();
    String pSemanticTypes = ((Concept) pUimaAnnotation).getCategories();
    String referenceDate = ((Concept) pUimaAnnotation).getReferenceDate();
    String eventDate = ((Concept) pUimaAnnotation).getEventDate();
    String statementDate = ((Concept) pUimaAnnotation).getStatementDate();

    String pBrandName = ((Medication) pUimaAnnotation).getBrandName();
    String pStrength = ((Medication) pUimaAnnotation).getStrength();
    String pDoseForm = ((Medication) pUimaAnnotation).getDoseForm();
    String pIndication = ((Medication) pUimaAnnotation).getIndication();
    String pInstructions = ((Medication) pUimaAnnotation).getInstructions();

    String pStartedDate = ((Medication) pUimaAnnotation).getStartedDate();
    String pStoppedDate = ((Medication) pUimaAnnotation).getStoppedDate();
    String pPrescribedDate = ((Medication) pUimaAnnotation).getPrescribedDate();
    String pFilledDate = ((Medication) pUimaAnnotation).getFilledDate();
    String pStatus = ((Medication) pUimaAnnotation).getStatus();

    String otherInfo = ((Concept) pUimaAnnotation).getOtherInfo();
    String sourceId = "";
    String sourceTerminology = "";
    if (otherInfo != null) {
      String[] otherInfoCols = U.split(otherInfo);
      if (otherInfoCols != null && otherInfoCols.length > 8) {

        sourceTerminology = otherInfoCols[7];
        sourceId = otherInfoCols[8];
      }
    } else {
      // shapes are concepts - they don't have otherInfo
    }

    returnVal = new com.ciitizen.framework.containers.json.MedicationConcept(pLabel, pId,
        pCoveredText, pProvenance, pAssertionProperties, pSection, pOffsets, parentAnnotationId,
        pConceptName, pConceptId, pSemanticTypes, referenceDate, statementDate, eventDate, sourceId,
        sourceTerminology, pBrandName, pStrength, pDoseForm, pIndication, pInstructions,
        pStartedDate, pStoppedDate, pPrescribedDate, pFilledDate, pStatus);

    return returnVal;
  } // end Method createConcept() --------------------

  // =================================================
  /**
   * createGeneObservationConcept includes the clinical status, start date,
   * stopped date, prescribedDate, filledDate, doseForm, strength, indication
   * [tbd], instructions[tbd], brandName[tbd], .
   *
   * @param pUimaAnnotation the uima annotation
   * @param pLabel the label
   * @param pId the id
   * @param pCoveredText the covered text
   * @param pProvenance the provenance
   * @param pAssertionProperties the assertion properties
   * @param pSection the section
   * @param pOffsets the offsets
   * @param parentAnnotationId the parent annotation id
   * @param pReferenceDate the reference date
   * @param pEventDate the event date
   * @return JsonAnnotation
   */
  // =================================================
  private JsonAnnotation createObservationConcept(Annotation pUimaAnnotation, String pLabel,
    String pId, String pCoveredText, String pProvenance, AssertionProperties pAssertionProperties,
    String pSection, Offsets pOffsets, String parentAnnotationId, String pReferenceDate,
    String pEventDate) {

    JsonAnnotation returnVal = null;

    // String pSemanticTypes = ((Concept)pUimaAnnotation).getCategories();
    String referenceDate = ((Concept) pUimaAnnotation).getReferenceDate();
    String eventDate = ((Concept) pUimaAnnotation).getEventDate();
    String statementDate = ((Concept) pUimaAnnotation).getStatementDate();

    String testName = ((Observation) pUimaAnnotation).getTestName();
    String testValue = ((Observation) pUimaAnnotation).getTestValue();
    String testRange = ((Observation) pUimaAnnotation).getResultRange();
    String testComment = ((Observation) pUimaAnnotation).getComment();
    String testInterpretation = ((Observation) pUimaAnnotation).getInterpretation();

    returnVal = new com.ciitizen.framework.containers.json.Observation(pLabel, pId, pCoveredText,
        pProvenance, pSection, pAssertionProperties, pOffsets, referenceDate, statementDate,
        eventDate, testName, testValue, testRange, testComment, testInterpretation);

    return returnVal;
  } // end Method createConcept() --------------------
  // =================================================

  /**
   * createVitalsObservationConcept is an extension of observationConcept in
   * that the testName has a concept ids, semantic types and the like.
   *
   * @param pUimaAnnotation the uima annotation
   * @param pLabel the label
   * @param pId the id
   * @param pCoveredText the covered text
   * @param pProvenance the provenance
   * @param pAssertionProperties the assertion properties
   * @param pSection the section
   * @param pOffsets the offsets
   * @param parentAnnotationId the parent annotation id
   * @param pReferenceDate the reference date
   * @param pEventDate the event date
   * @return JsonAnnotation
   */
  // =================================================
  private JsonAnnotation createVitalsObservationConcept(Annotation pUimaAnnotation, String pLabel,
    String pId, String pCoveredText, String pProvenance, AssertionProperties pAssertionProperties,
    String pSection, Offsets pOffsets, String parentAnnotationId, String pReferenceDate,
    String pEventDate) {

    JsonAnnotation returnVal = null;

    // String pSemanticTypes = ((Concept)pUimaAnnotation).getCategories();
    String referenceDate = ((Concept) pUimaAnnotation).getReferenceDate();
    String eventDate = ((Concept) pUimaAnnotation).getEventDate();
    String statementDate = ((Concept) pUimaAnnotation).getStatementDate();

    String testName = ((Observation) pUimaAnnotation).getTestName();
    String testValue = ((Observation) pUimaAnnotation).getTestValue();
    String testRange = ((Observation) pUimaAnnotation).getResultRange();
    String testComment = ((Observation) pUimaAnnotation).getComment();
    String testInterpretation = ((Observation) pUimaAnnotation).getInterpretation();

    String conceptNames = ((Observation) pUimaAnnotation).getConceptNames();
    String semanticTypes = ((Concept) pUimaAnnotation).getCategories();
    String otherInfo = ((Concept) pUimaAnnotation).getOtherInfo();
    String cuis = null;
    String sourceId = null;
    String sourceTerminology = null;

    // 0 1 2 3 4 5 6 7 8 9 10|11|12|13|4
    // C1519530|title|<noun>|<all>|Title|Title|T078|NCI|C19067|n|0 |S
    // |PF|title|1

    if (otherInfo != null && otherInfo.trim().length() > 0) {
      String[] cols = U.split(otherInfo);
      if (cols.length > 7) {
        cuis = cols[0];
        sourceId = cols[8];
        sourceTerminology = cols[7];

      }
    }

    returnVal = new com.ciitizen.framework.containers.json.Observation(pLabel, pId, pCoveredText,
        pProvenance, pSection, pAssertionProperties, pOffsets, referenceDate, statementDate,
        eventDate, testName, testValue, testRange, testComment, testInterpretation,
        parentAnnotationId, conceptNames, semanticTypes, cuis, sourceId, sourceTerminology

    );

    return returnVal;
  } // end Method createConcept() --------------------

  // =================================================
  /**
   * createGeneObservationConcept includes the clinical status, start date,
   * stopped date, prescribedDate, filledDate, doseForm, strength, indication
   * [tbd], instructions[tbd], brandName[tbd], .
   *
   * @param pUimaAnnotation the uima annotation
   * @param pLabel the label
   * @param pId the id
   * @param pCoveredText the covered text
   * @param pProvenance the provenance
   * @param pAssertionProperties the assertion properties
   * @param pSection the section
   * @param pOffsets the offsets
   * @param parentAnnotationId the parent annotation id
   * @param pReferenceDate the reference date
   * @param pEventDate the event date
   * @return JsonAnnotation
   */
  // =================================================
  private JsonAnnotation createGeneObservationConcept(Annotation pUimaAnnotation, String pLabel,
    String pId, String pCoveredText, String pProvenance, AssertionProperties pAssertionProperties,
    String pSection, Offsets pOffsets, String parentAnnotationId, String pReferenceDate,
    String pEventDate) {

    JsonAnnotation returnVal = null;

    // String pSemanticTypes = ((Concept)pUimaAnnotation).getCategories();
    String referenceDate = ((Concept) pUimaAnnotation).getReferenceDate();
    String eventDate = ((Concept) pUimaAnnotation).getEventDate();
    String statementDate = ((Concept) pUimaAnnotation).getStatementDate();

    String testName = ((Observation) pUimaAnnotation).getTestName();
    String testValue = ((Observation) pUimaAnnotation).getTestValue();
    // String testRange = ((Observation)pUimaAnnotation).getResultRange();
    // String testComment = ((Observation)pUimaAnnotation).getComment();
    String testInterpretation = ((Observation) pUimaAnnotation).getInterpretation(); // <----
                                                                                     // contains
                                                                                     // the
                                                                                     // gene
                                                                                     // Varient
    String therapies = ((GeneObservation) pUimaAnnotation).getTherapies();

    returnVal = new com.ciitizen.framework.containers.json.GeneObservation(pLabel, pId,
        pCoveredText, pProvenance, pSection, pAssertionProperties, pOffsets, referenceDate,
        statementDate, eventDate, testName, testInterpretation, therapies, testValue);

    return returnVal;
  } // end Method createConcept() --------------------

  // =================================================
  /**
   * createObservationsPanel includes the clinical status, panel name, event
   * date, and a set of observations.
   *
   * @param pUimaAnnotation the uima annotation
   * @param pLabel the label
   * @param pId the id
   * @param pCoveredText the covered text
   * @param pProvenance the provenance
   * @param pAssertionProperties the assertion properties
   * @param pSection the section
   * @param pOffsets the offsets
   * @param parentAnnotationId the parent annotation id
   * @param pReferenceDate the reference date
   * @param pEventDate the event date
   * @return JsonAnnotation
   */
  // =================================================
  private final JsonAnnotation createObservationsPanel(Annotation pUimaAnnotation, String pLabel,
    String pId, String pCoveredText, String pProvenance, AssertionProperties pAssertionProperties,
    String pSection, Offsets pOffsets, String parentAnnotationId, String pReferenceDate,
    String pEventDate) {

    JsonAnnotation returnVal = null;
    JCas jcas = null;
    try {
      jcas = pUimaAnnotation.getCAS().getJCas();
    } catch (CASException e) {
      // n/a
    }

    // String pSemanticTypes = ((Concept)pUimaAnnotation).getCategories();
    String referenceDate = ((Concept) pUimaAnnotation).getReferenceDate();
    String eventDate = ((Concept) pUimaAnnotation).getEventDate();
    String statementDate = ((Concept) pUimaAnnotation).getStatementDate();
    String parentId = ((Concept) pUimaAnnotation).getId();

    String panelName = ((ObservationsPanel) pUimaAnnotation).getPanelName();
    String clinicalStatus = ((ObservationsPanel) pUimaAnnotation).getClinicalStatus();
    String comments = ((ObservationsPanel) pUimaAnnotation).getComments();
    FSArray observationz = ((ObservationsPanel) pUimaAnnotation).getObservations();

    List<com.ciitizen.framework.containers.json.Observation> jsonObservations = null;
    if (observationz != null && observationz.size() > 0) {
      @SuppressWarnings("unchecked")
      List<Annotation> uimaObservations = UIMAUtil.fSArray2List(jcas, observationz);
      jsonObservations = createJsonObservations(jcas, parentId, uimaObservations);
    }

    returnVal = new com.ciitizen.framework.containers.json.ObservationsPanel(pLabel, pId,
        pCoveredText, pProvenance, pSection, pAssertionProperties, pOffsets, referenceDate,
        statementDate, eventDate, panelName, clinicalStatus, jsonObservations, comments);

    return returnVal;
  } // end Method createObservationsPanel() --------------------

  // =================================================
  /**
   * createJsonObservations transforms uima observations into a list of json
   * observations.
   *
   * @param pJCas the j cas
   * @param pParentId the parent id
   * @param pUimaObservations the uima observations
   * @return List<com.ciitizen.framework.containers.json.Observation>
   */
  // =================================================
  private final List<com.ciitizen.framework.containers.json.Observation> createJsonObservations(
    JCas pJCas, String pParentId, List<Annotation> pUimaObservations) {

    List<com.ciitizen.framework.containers.json.Observation> jsonObservations = null;
    if (pUimaObservations != null && pUimaObservations.size() > 0) {
      jsonObservations = new ArrayList<com.ciitizen.framework.containers.json.Observation>(
          pUimaObservations.size());

      for (Annotation observation : pUimaObservations) {

        com.ciitizen.framework.containers.json.Observation jsonObservation = null;

        Offsets offsets = getOffsets(observation);
        String label = getAnnotationLabel(observation);
        String provenance = getProvenance(observation);
        String id = getId(observation);
        String section = getSection(pJCas, observation);
        String coveredText = observation.getCoveredText();
        String eventDate = ((Observation) observation).getEventDate();
        String referenceDate = ((Observation) observation).getReferenceDate();

        String otherInfo = ((Concept) observation).getOtherInfo();

        AssertionProperties assertedProperties = getAssertionProperties(pJCas, observation);

        if (otherInfo != null && otherInfo.trim().length() > 0) {
          jsonObservation =
              (com.ciitizen.framework.containers.json.Observation) createVitalsObservationConcept(
                  observation, label, id, coveredText, provenance, assertedProperties, section,
                  offsets, pParentId, referenceDate, eventDate);

        } else {

          jsonObservation = (com.ciitizen.framework.containers.json.Observation)

          createObservationConcept(observation, label, id, coveredText, provenance,
              assertedProperties, section, offsets, pParentId, referenceDate, eventDate);
        }
        jsonObservations.add(jsonObservation);

      }

    }
    return jsonObservations;
  } // end Method createJsonObservations () ----

  // =================================================
  /**
   * createCodedEntry .
   *
   * @param pUimaAnnotation the uima annotation
   * @param pLabel the label
   * @param pId the id
   * @param pCoveredText the covered text
   * @param pProvenance the provenance
   * @param pAssertionProperties the assertion properties
   * @param pSection the section
   * @param pOffsets the offsets
   * @param pParentAnnotationId the parent annotation id
   * @return JsonAnnotation
   */
  // =================================================
  private JsonAnnotation createCodedEntry(Annotation pUimaAnnotation, String pLabel, String pId,
    String pCoveredText, String pProvenance, AssertionProperties pAssertionProperties,
    String pSection, Offsets pOffsets, String pParentAnnotationId)

  {

    JsonAnnotation returnVal = null;
    String conceptName = ((gov.va.chir.model.CodedEntry) pUimaAnnotation).getDisplayName();
    String conceptId = ((gov.va.chir.model.CodedEntry) pUimaAnnotation).getCodeCode();
    String semanticTypes[] = UIMAUtil.stringArrayToArrayOfString(
        ((gov.va.chir.model.CodedEntry) pUimaAnnotation).getSemanticType());
    String semanticGroups[] = UIMAUtil.stringArrayToArrayOfString(
        ((gov.va.chir.model.CodedEntry) pUimaAnnotation).getSemanticGroup());
    String terminologyName = ((gov.va.chir.model.CodedEntry) pUimaAnnotation).getCodeSystem();
    String terminologyVersion =
        ((gov.va.chir.model.CodedEntry) pUimaAnnotation).getCodeSystemName();
    double score = 0.0;
    returnVal = new com.ciitizen.framework.containers.json.CodedEntry(pLabel, pId, pCoveredText,
        pProvenance, pAssertionProperties, pSection, pOffsets, pParentAnnotationId, conceptName,
        conceptId, semanticTypes, semanticGroups, terminologyName, terminologyVersion, score);

    return returnVal;
  } // end Method createCodedEntry() -----------------

  // =================================================
  /**
   * createClinicalStatement .
   *
   * @param pJCas the j cas
   * @param pUimaAnnotation the uima annotation
   * @param pLabel the label
   * @param pId the id
   * @param pCoveredText the covered text
   * @param pProvenance the provenance
   * @param pSection the section
   * @param pOffsets the offsets
   * @param pAssertionProperties the assertion properties
   * @param pReferenceDate the reference date
   * @param pEventDate the event date
   * @return JsonAnnotation
   */
  // =================================================
  private JsonAnnotation createClinicalStatement(JCas pJCas, Annotation pUimaAnnotation,
    String pLabel, String pId, String pCoveredText, String pProvenance, String pSection,
    Offsets pOffsets, AssertionProperties pAssertionProperties, String pReferenceDate,
    String pEventDate) {

    JsonAnnotation returnVal = null;

    // Snippet context = getAnnotationContext(pJCas, this.numberOfContextLines,
    // pUimaAnnotation);

    // List<com.ciitizen.framework.containers.json.CodedEntry> codedEntries =
    // getCodedEntries( pUimaAnnotation );
    returnVal = new com.ciitizen.framework.containers.json.ClinicalStatement();

    return returnVal;
  } // end Method createClinicalStatement() -----------

  // =================================================
  /**
   * createJsonTerm .
   *
   * @param pUimaAnnotation the uima annotation
   * @param pLabel the label
   * @param pId the id
   * @param pCoveredText the covered text
   * @param pProvenance the provenance
   * @param pSection the section
   * @param pOffsets the offsets
   * @param pAssertionProperties the assertion properties
   * @param pParentAnnotationId the parent annotation id
   * @return the json annotation
   */
  // =================================================
  private JsonAnnotation createJsonTerm(Annotation pUimaAnnotation, String pLabel, String pId,
    String pCoveredText, String pProvenance, String pSection, Offsets pOffsets,
    AssertionProperties pAssertionProperties, String pParentAnnotationId) {

    JsonAnnotation returnVal = null;

    String codeCodes = UIMAUtil.stringArrayToString(((LexicalElement) pUimaAnnotation).getEuis());
    String citationForm = ((LexicalElement) pUimaAnnotation).getCitationForm();
    String stemmedKey = ((LexicalElement) pUimaAnnotation).getStemmedKey();
    String semanticTypez = ((LexicalElement) pUimaAnnotation).getSemanticTypes();
    String[] semanticTypes = null;
    if (semanticTypez != null)
      semanticTypes = U.split(semanticTypez, ":");

    Annotation predicate = ((LexicalElement) pUimaAnnotation).getAssertionPredicate();
    String predicateId = getId(predicate);

    boolean isHead = ((LexicalElement) pUimaAnnotation).getHead();
    boolean inProse = ((LexicalElement) pUimaAnnotation).getInProse();
    boolean isAcronym = ((LexicalElement) pUimaAnnotation).getIsAcronym();
    boolean isAcronymExpansion = ((LexicalElement) pUimaAnnotation).getIsAcronymExpansion();
    String pos = ((LexicalElement) pUimaAnnotation).getPos();
    StringArray otherInfoz = ((LexicalElement) pUimaAnnotation).getOtherFeatures();
    String[] otherInfo = null;
    if (otherInfoz != null)
      otherInfo = UIMAUtil.stringArrayToArrayOfString(otherInfoz);

    returnVal = new com.ciitizen.framework.containers.json.Term(pLabel, pId, pCoveredText,
        pProvenance, pSection, pOffsets, pAssertionProperties, pParentAnnotationId, codeCodes,
        citationForm, stemmedKey, semanticTypes, predicateId, isHead, inProse, isAcronym,
        isAcronymExpansion, pos, otherInfo);

    return returnVal;
  }

  // =================================================
  /**
   * getId will return the original annoation id.
   *
   * @param pUimaAnnotation the uima annotation
   * @return String null if the the annotation passed in is null
   */
  // =================================================
  private final String getId(Annotation pUimaAnnotation) {
    String returnVal = null;

    if (pUimaAnnotation != null)
      try {
        returnVal = ((VAnnotation) pUimaAnnotation).getId();
      } catch (Exception e) {
        try {
          returnVal = ((Concept) pUimaAnnotation).getId();
        } catch (Exception e2) {
          // not a ciitizen or va annotation, make one up
          String labelName = getAnnotationLabel(pUimaAnnotation);
          returnVal = "JsonMarshaller_" + labelName + "_" + this.jsonAnnotationCtr++;
          // these will never be noted as parents of something else
        }
      }
    return returnVal;
  } // end Method getID() ----------------------------

  // =================================================
  /**
   * getProvenance returns either the original provenance or this class as the
   * provenance.
   *
   * @param pUimaAnnotation the uima annotation
   * @return String
   */
  // =================================================
  private final String getProvenance(Annotation pUimaAnnotation) {

    String returnVal = "";
    try {
      returnVal = ((VAnnotation) pUimaAnnotation).getProvenance();
    } catch (Exception e) {
      // n/a
    }

    return returnVal;
  } // end Method getProvenance() --------------------

  // =================================================
  /**
   * getOffsets .
   *
   * @param pUimaAnnotation the uima annotation
   * @return Offsets
   */
  // =================================================
  private final Offsets getOffsets(Annotation pUimaAnnotation) {
    Offsets returnVal = new Offsets();

    returnVal.setBeginOffset(pUimaAnnotation.getBegin());
    returnVal.setEndOffset(pUimaAnnotation.getEnd());
    return returnVal;
  } // end Method getOffsets() ----------------------

  // =================================================
  /**
   * getAnnotationLabel returns the name/label/category of this annotatation
   * sans the namespace part.
   *
   * @param pUimaAnnotation the uima annotation
   * @return String
   */
  // =================================================
  private final String getAnnotationLabel(Annotation pUimaAnnotation) {

    String returnVal = null;
    returnVal = pUimaAnnotation.getClass().getName();
    if (returnVal != null) {
      int lastP = returnVal.lastIndexOf('.');
      if (lastP > -1)
        returnVal = returnVal.substring(lastP + 1);
    }

    return FW_JSON_PKG + returnVal;
  } // end Method getAnnotationLabel() ---------------

  // =================================================
  /**
   * getAnnotationContext returns a structure called a Snippet that encapsulates
   * the lines before, the line of, the lines after the term in focus.
   *
   * @param pJCas the j cas
   * @param pNumberOfContextLines (the N number of lines before or after)
   * @param pUimaAnnotation the uima annotation
   * @return Snippet
   */
  // =================================================
  @SuppressWarnings("unused")
  private final Snippet getAnnotationContext(JCas pJCas, int pNumberOfContextLines,
    Annotation pUimaAnnotation) {
    Snippet snippet = new Snippet();

    String docText = pJCas.getDocumentText();

    SectionZone section = (SectionZone) VUIMAUtil.getSection(pJCas, pUimaAnnotation);
    String linesBefore =
        getLinesBefore(docText, pNumberOfContextLines, pUimaAnnotation.getBegin(), section);
    String linesAfter =
        getLinesAfter(docText, pNumberOfContextLines, pUimaAnnotation.getEnd(), section);
    String stuffBefore = getStuffBefore(docText, pUimaAnnotation.getBegin());
    String stuffAfter = getStuffAfter(docText, pUimaAnnotation.getEnd());
    String contextBefore = linesBefore + stuffBefore;
    String contextAfter = stuffAfter + linesAfter;

    String focusTerm = pUimaAnnotation.getCoveredText();

    snippet.setContextBefore(contextBefore);
    snippet.setContextAfter(contextAfter);
    snippet.setFocusTerm(focusTerm);

    return snippet;
  } // end Method getAnnotationContext() -------------

  // =================================================
  /**
   * getLinesBefore
   * 
   * Thought experiment - how to incorporate into this truncating this to be
   * within the section bounds. We don't want to capture the previous section -
   * that could involve a topic shift, confusing the context.
   *
   * @param pDocText the doc text
   * @param pNumberOfLines the number of lines
   * @param pBegin the begin
   * @param pSection - truncate the snippet to the bounds of the section
   * @return the lines before
   */
  // =================================================
  private String getLinesBefore(String pDocText, int pNumberOfLines, int pBegin,
    SectionZone pSection) {

    String returnVal = "";
    char[] docTextChars = pDocText.toCharArray();
    int startOffset = 0;
    int endOffset = 0;

    int newlinesSeen = 0;
    boolean firstNewLineSeen = false;
    for (int i = pBegin; i >= 0; i--) {

      if (docTextChars[i] == '\n') {
        newlinesSeen++;
      }
      if (newlinesSeen == 1 && !firstNewLineSeen) {
        endOffset = i;
        firstNewLineSeen = true;
      }
      if (newlinesSeen == pNumberOfLines + 1) {
        startOffset = i + 1;
        break;
      }
    }

    if (endOffset > 0) {

      if (pSection != null && startOffset < pSection.getBegin())
        startOffset = pSection.getBegin();

      returnVal = pDocText.substring(startOffset, endOffset);
    }
    return returnVal;

  } // end Method getLinesBefore() -------------------

  // =================================================
  /**
   * getStuffBefore returns from the newline before the annotation to the
   * beginning of the annotation.
   *
   * @param pDocText the doc text
   * @param pBegin the begin
   * @return String
   */
  // =================================================
  private final String getStuffBefore(String pDocText, int pBegin) {

    String returnVal = "";
    char[] docTextChars = pDocText.toCharArray();
    int startOffset = 0;
    int endOffset = pBegin - 1;

    for (int i = pBegin; i >= 0; i--) {

      if (docTextChars[i] == '\n') {
        startOffset = i + 1;
        break;
      }
    }

    if (endOffset > 0 && startOffset > -1 && startOffset < pDocText.length()
        && endOffset <= pDocText.length() && endOffset > startOffset)
      returnVal = pDocText.substring(startOffset, endOffset);

    return returnVal;
  } // end getLineOfAnnotation() ---------------------

  // =================================================
  /**
   * getStuffAfter returns from the end of the annotation to the next newline.
   *
   * @param pDocText the doc text
   * @param pEnd the end
   * @return String
   */
  // =================================================
  private final String getStuffAfter(String pDocText, int pEnd) {

    String returnVal = "";
    char[] docTextChars = pDocText.toCharArray();
    int startOffset = pEnd + 1;
    int endOffset = 0;

    for (int i = pEnd; i < pDocText.length(); i++) {

      endOffset = i;
      if (docTextChars[i] == '\n')
        break;

    }

    if (startOffset > 0 && endOffset > startOffset)
      returnVal = pDocText.substring(startOffset, endOffset + 1);

    return returnVal;
  } // end getLineOfAnnotation() ---------------------

  // =================================================
  /**
   * getLinesAfter .
   *
   * @param pDocText the doc text
   * @param pNumberOfLines the number of lines
   * @param pEnd the end
   * @param pSection the section
   * @return String
   */
  // =================================================
  private final String getLinesAfter(String pDocText, int pNumberOfLines, int pEnd,
    SectionZone pSection) {

    String returnVal = "";
    char[] docTextChars = pDocText.toCharArray();
    int startOffset = 0;
    int endOffset = 0;

    int newlinesSeen = 0;
    boolean firstNewLineSeen = false;
    for (int i = pEnd; i < pDocText.length(); i++) {

      if (docTextChars[i] == '\n') {
        newlinesSeen++;
      }
      if (newlinesSeen == 1 && !firstNewLineSeen) {
        startOffset = i;
        firstNewLineSeen = true;
      }
      if (newlinesSeen == pNumberOfLines + 1) {
        endOffset = i;
        break;
      }
    }

    if (startOffset > 0 && endOffset > startOffset) {

      if (pSection != null && endOffset > pSection.getBegin())
        endOffset = pSection.getBegin() - 1;
      returnVal = pDocText.substring(startOffset, endOffset);

    }
    return returnVal;
  } // end Method getLinesAfter() -------------------

  // =================================================
  /**
   * getAssertionProperties .
   *
   * @param pJCas the j cas
   * @param pUimaAnnotation the uima annotation
   * @return AssertionProperties
   */
  // =================================================
  private final AssertionProperties getAssertionProperties(JCas pJCas, Annotation pUimaAnnotation) {
    AssertionProperties props = new AssertionProperties();

    boolean assertionProps[] = VUIMAUtil.getAssertionProperties(pJCas, pUimaAnnotation);

    props.setAsserted(assertionProps[0]);
    props.setConditional(assertionProps[1]);
    props.setHistorical(assertionProps[2]);
    props.setHypothetical(assertionProps[3]);
    props.setSubject(assertionProps[4]);

    return props;

  } // end Method getAssertionProperties

  // =================================================
  /**
   * getSection returns the section name that's on the concept or vannotation.
   * I.e., it's lazy, it doesn't compute the section it's in, only takes from
   * what was noted in the creation of the vannoation or concept instances.
   * Others need not apply.
   *
   * @param pJCas the j cas
   * @param pUimaAnnotation the uima annotation
   * @return String
   */
  // =================================================
  private final String getSection(JCas pJCas, Annotation pUimaAnnotation) {
    String sectionName = VUIMAUtil.getSectionName(pJCas, pUimaAnnotation);
    return sectionName;
  } // end Method getSection() -----------------------

  // =================================================
  /**
   * getParentAnnotationId will return the id from the parent provided the
   * parent is a VAnnotation.
   *
   * @param pUimaAnnotation the uima annotation
   * @return String
   */
  // =================================================
  private final String getParentAnnotationId(Annotation pUimaAnnotation) {
    String returnVal = null;

    Annotation parent = null;
    try {
      parent = ((VAnnotation) pUimaAnnotation).getParent();
      if (parent != null) {
        returnVal = ((VAnnotation) parent).getId();
        if (returnVal == null) {
          // n/a
        }
      }
    } catch (Exception e) {
      // n/a
    }

    return returnVal;
  } // end method getParentAnnotationId() -----------

  // =================================================
  /**
   * getCodedEntries retrieves the concept mappings from the clinicalStatements
   * (and if none, the concepts).
   *
   * @param pUimaAnnotation the uima annotation
   * @return List<CodedEntry>
   */
  // =================================================
  @SuppressWarnings("unused")
  private final List<CodedEntry> getCodedEntries(Annotation pUimaAnnotation) {

    List<CodedEntry> returnVal = null;
    if (pUimaAnnotation.getClass().getName().endsWith("ClinicalStatement")) {
      returnVal = getCodedEntries(((ClinicalStatement) pUimaAnnotation));
    }

    return returnVal;

  } // end Method getCodedEntries() ---------------

  // =================================================
  /**
   * getCodedEntries .
   *
   * @param pClinicalStatement the clinical statement
   * @return List<CodedEntry>
   */
  // =================================================
  private final List<com.ciitizen.framework.containers.json.CodedEntry> getCodedEntries(
    ClinicalStatement pClinicalStatement) {

    List<CodedEntry> returnValz = null;
    FSArray mappingz = pClinicalStatement.getCodedEntries();
    String parentAnnotationId = pClinicalStatement.getId();

    if (mappingz != null && mappingz.size() > 0) {
      returnValz = new ArrayList<CodedEntry>(mappingz.size());
      for (int i = 0; i < mappingz.size(); i++) {
        gov.va.chir.model.CodedEntry mapping = (gov.va.chir.model.CodedEntry) mappingz.get(i);
        String sourceTerminologyVersion = mapping.getCodeSystemName(); // <----
                                                                       // looks
                                                                       // backwards,
                                                                       // but
                                                                       // producing
                                                                       // the
                                                                       // right
                                                                       // thing
        String sourceTerminologyName = mapping.getCodeSystem(); // <----
        String coveredText = mapping.getCoveredText();

        CodedEntry jsonCodedEntry = new CodedEntry();
        jsonCodedEntry.setCoveredText(coveredText);
        jsonCodedEntry.setAnnotationLabel(mapping.getClass().getName());
        jsonCodedEntry.setId(mapping.getId());
        jsonCodedEntry.setParentAnnotationId(parentAnnotationId);
        jsonCodedEntry.setCodeCode(mapping.getCodeCode());
        String conceptName = mapping.getDisplayName();

        jsonCodedEntry.setCodeName(conceptName);
        jsonCodedEntry.setScore(0.0);
        // StringArray semanticTypez = mapping.getSemanticType();

        String semanticTypes[] = UIMAUtil.stringArrayToArrayOfString(mapping.getSemanticType());
        // String semanticGroups[] =
        // UIMAUtil.stringArrayToArrayOfString(((gov.va.chir.model.CodedEntry)mapping).getSemanticGroup());

        jsonCodedEntry.setSemanticTypes(semanticTypes);
        jsonCodedEntry.setTerminologyName(sourceTerminologyName);
        jsonCodedEntry.setTerminologyVersion(sourceTerminologyVersion);

        returnValz.add(jsonCodedEntry);
      } // end loop thru mappings
    } // end if there are any mappings

    return returnValz;

  } // end Method getCodedEntries() ---------------

  // =================================================
  /**
   * setMetaData sets the non-annotation stuff for the JsonDocumentAnnotations.
   *
   * @param pJDoc the j doc
   * @param pDocumentHeader the document header
   */
  // =================================================
  private final void setMetaData(JsonDocumentAnnotations pJDoc, DocumentHeader pDocumentHeader) {

    pJDoc.setDocumentId(pDocumentHeader.getDocumentId());
    pJDoc.setDocumentName(pDocumentHeader.getDocumentName());
    pJDoc.setDocumentType(pDocumentHeader.getDocumentType());
    pJDoc.setPatientId(pDocumentHeader.getPatientID());

    Date referenceDate = null;
    String refDateString = pDocumentHeader.getReferenceDate();

    try {

      if (refDateString != null && refDateString.trim().length() == 0) {

        referenceDate = null;
      } else {
        referenceDate = this.dataMatcher.getDate(refDateString);

      }

      pJDoc.setReferenceDateTime(referenceDate);

    } catch (Exception e) {
      e.printStackTrace();
      String msg = "Issue trying to convert the reference date - likely a divient format  "
          + refDateString + "| " + e.toString();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "setMetaData", msg);
    }
    Map<String, String> otherMetaDataMap = getOtherMetaData(pDocumentHeader);

    pJDoc.setOtherMetaData(otherMetaDataMap);

  } // end Method setMetaData()

  // =================================================
  /**
   * getOtherMetaData .
   *
   * @param pDocumentHeader the document header
   * @return the other meta data
   */
  // =================================================
  private final Map<String, String> getOtherMetaData(DocumentHeader pDocumentHeader) {

    HashMap<String, String> returnVal = null;

    String otherMetaData = pDocumentHeader.getOtherMetaData();

    if (otherMetaData != null && !otherMetaData.isEmpty()) {
      returnVal = new HashMap<String, String>();
      String fieldNamez = pDocumentHeader.getOtherMetaDataFieldNames();
      String[] fieldNames = null;
      if (fieldNamez != null) {
        fieldNames = U.split(fieldNamez);
        String[] values = U.split(otherMetaData);

        try {
          for (int i = 0; i < fieldNames.length; i++)
            returnVal.put(fieldNames[i], values[i]);

        } catch (Exception e) {
          e.printStackTrace();
          GLog.println(GLog.ERROR_LEVEL,
              "issue with converting otherMetaData to a  Map<> " + e.toString());
        }
      }
    }
    return returnVal;
  } // end Method getOtherMetaData() ---------

  // =======================================================
  /**
   * renderFileName figures out the input file Name, creates a path to the
   * appropriate output directory, with the appropriate extension on it.
   *
   * @param pJCas the j cas
   * @param pOutputDir the output dir
   * @return the string
   */
  // =======================================================
  private String renderFileName(JCas pJCas, String pOutputDir) {

    String outputFileName = null;

    // ----- retrieve the fileName from the documentHeader
    String fullInputFileName = VUIMAUtil.getDocumentId(pJCas);

    // ----- just get the fileName
    if (fullInputFileName == null)
      fullInputFileName = "InputFile" + this.counter++;
    String name = U.getOnlyFileName(fullInputFileName);
    String nameNoExtension = U.getFileNamePrefix(name);

    outputFileName = this.outputDir + "/" + nameNoExtension + ".json";

    return outputFileName;

  } // End Method renderFileName() ======================

  // -----------------------------------------
  /**
   * 
   * destroy .
   */
  // -----------------------------------------
  @Override
  public void destroy() {
    try {
      this.performanceMeter.writeProfile(this.getClass().getSimpleName());
    } catch (Exception e) {
      e.printStackTrace();
      GLog.println(GLog.ERROR_LEVEL, "Issue destroying Json Writer " + e.toString());

    }
  } // end Method destroy()

  // ----------------------------------
  /**
   * initialize picks up the parameters needed to write a cas out to the
   * database.
   *
   * @param aContext the a context
   * @throws ResourceInitializationException the resource initialization
   *           exception
   */
  // ----------------------------------
  @Override
  public void initialize(UimaContext aContext) throws ResourceInitializationException {

    String args[] = null;
    args = (String[]) aContext.getConfigParameterValue("args");

    initialize(args);

  } // end Method initialize() --------------

  // ----------------------------------
  /**
   * initialize picks up the parameters for the json process
   * 
   * This class is looking for where to put the output files. --outputDir=xxx to
   * which, a ./json dir will be created
   * 
   * This class is looking for --numberOfContextLines=x as an argument. This
   * attribute sets the number of lines before and number of lines after the
   * focus term. The default is 3 lines before and 3 lines after. I.e., x=3 by
   * default.
   *
   * @param pArgs the args
   * @throws ResourceInitializationException the resource initialization
   *           exception
   */
  // ----------------------------------
  @Override
  public void initialize(String[] pArgs) throws ResourceInitializationException {

    this.numberOfContextLines =
        Integer.parseInt(U.getOption(pArgs, "--numberOfContextLines=", "3"));
    this.outputDir = U.getOption(pArgs, "--outputDir=", "./someOutputDir") + "/json";

    this.performanceMeter = new ProfilePerformanceMeter(pArgs, this.getClass().getSimpleName());

    try {
      if (!this.outputDir.equals("./someOutputDir")) // <---- don't make the dir
                                                     // if the arg is not set
        U.mkDir(this.outputDir);

    } catch (Exception e) {
      e.getStackTrace();
      String msg = "Issue creating the json outputDir " + e.getMessage();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "initialize", msg);
      throw new ResourceInitializationException();
    }

    try {
      this.dataMatcher = new DefaultDataTypeMatcher();
    } catch (Exception e) {
      e.getStackTrace();
      String msg = "Issue trying to create a datamatcher in the json writer " + e.getMessage();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "initialize", msg);
      throw new ResourceInitializationException();
    }

    try {
      if (this.htmlWriter == null)
        this.htmlWriter = new HTMLWriter(pArgs);
    } catch (Exception e) {
      e.getStackTrace();
      String msg = "Issue trying to create an html writer " + e.getMessage();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "initialize", msg);
      throw new ResourceInitializationException();
    }

    try {
      this.sectionViewAnnotator = new SectionViewAnnotator();
      this.sectionViewAnnotator.initialize(pArgs);
    } catch (Exception e) {
      e.getStackTrace();
      String msg = "Issue trying to create an html writer " + e.getMessage();
      GLog.println(GLog.ERROR_LEVEL, this.getClass(), "initialize", msg);
      throw new ResourceInitializationException();
    }

  } // end Method initialize() ---------------

  // ----------------------------------------
  // Global variables
  /** The number of context lines. */
  // ----------------------------------------
  private int numberOfContextLines = 3;

  /** The output dir. */
  private String outputDir = null;

  /** The counter. */
  private int counter = 0;

  /** The json annotation ctr. */
  private int jsonAnnotationCtr = 0;

  /** The performance meter. */
  ProfilePerformanceMeter performanceMeter = null;

  /** The Constant FW_JSON_PKG. */
  private static final String FW_JSON_PKG = "com.ciitizen.framework.containers.json.";

  /** The html writer. */
  private HTMLWriter htmlWriter = null;

  /** The section view annotator. */
  private SectionViewAnnotator sectionViewAnnotator = null;

} // end Class JsonWriter
